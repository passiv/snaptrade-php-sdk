<?php
/**
 * TransactionsAndReportingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  SnapTrade
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * SnapTrade
 *
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 * Generated by: https://konfigthis.com
 */


namespace SnapTrade\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use SnapTrade\ApiException;
use SnapTrade\Configuration;
use SnapTrade\HeaderSelector;
use SnapTrade\ObjectSerializer;

class TransactionsAndReportingApi extends \SnapTrade\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getActivities' => [
            'application/json',
        ],
        'getReportingCustomRange' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation getActivities
     *
     * Get transaction history for a user
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  string $brokerage_authorizations Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations (optional)
     * @param  string $type Optional comma seperated list of types to filter activities by. This is not an exhaustive list, if we fail to match to these types, we will return the raw description from the brokerage. Potential values include - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivities'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\UniversalActivity[]
     */
    public function getActivities(
        $user_id,
        $user_secret,
        $start_date = SENTINEL_VALUE,
        $end_date = SENTINEL_VALUE,
        $accounts = SENTINEL_VALUE,
        $brokerage_authorizations = SENTINEL_VALUE,
        $type = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getActivities'][0]
    )
    {

        list($response) = $this->getActivitiesWithHttpInfo($user_id, $user_secret, $start_date, $end_date, $accounts, $brokerage_authorizations, $type, $contentType);
        return $response;
    }

    /**
     * Operation getActivitiesWithHttpInfo
     *
     * Get transaction history for a user
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  string $brokerage_authorizations Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations (optional)
     * @param  string $type Optional comma seperated list of types to filter activities by. This is not an exhaustive list, if we fail to match to these types, we will return the raw description from the brokerage. Potential values include - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivities'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\UniversalActivity[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivitiesWithHttpInfo($user_id, $user_secret, $start_date = null, $end_date = null, $accounts = null, $brokerage_authorizations = null, $type = null, string $contentType = self::contentTypes['getActivities'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getActivitiesRequest($user_id, $user_secret, $start_date, $end_date, $accounts, $brokerage_authorizations, $type, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getActivitiesWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $start_date,
                        $end_date,
                        $accounts,
                        $brokerage_authorizations,
                        $type,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\UniversalActivity[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\UniversalActivity[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\UniversalActivity[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\UniversalActivity[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\UniversalActivity[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivitiesAsync
     *
     * Get transaction history for a user
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  string $brokerage_authorizations Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations (optional)
     * @param  string $type Optional comma seperated list of types to filter activities by. This is not an exhaustive list, if we fail to match to these types, we will return the raw description from the brokerage. Potential values include - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivitiesAsync(
        $user_id,
        $user_secret,
        $start_date = SENTINEL_VALUE,
        $end_date = SENTINEL_VALUE,
        $accounts = SENTINEL_VALUE,
        $brokerage_authorizations = SENTINEL_VALUE,
        $type = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getActivities'][0]
    )
    {

        return $this->getActivitiesAsyncWithHttpInfo($user_id, $user_secret, $start_date, $end_date, $accounts, $brokerage_authorizations, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivitiesAsyncWithHttpInfo
     *
     * Get transaction history for a user
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  string $brokerage_authorizations Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations (optional)
     * @param  string $type Optional comma seperated list of types to filter activities by. This is not an exhaustive list, if we fail to match to these types, we will return the raw description from the brokerage. Potential values include - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivitiesAsyncWithHttpInfo($user_id, $user_secret, $start_date = null, $end_date = null, $accounts = null, $brokerage_authorizations = null, $type = null, string $contentType = self::contentTypes['getActivities'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\UniversalActivity[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getActivitiesRequest($user_id, $user_secret, $start_date, $end_date, $accounts, $brokerage_authorizations, $type, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivities'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  string $brokerage_authorizations Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations (optional)
     * @param  string $type Optional comma seperated list of types to filter activities by. This is not an exhaustive list, if we fail to match to these types, we will return the raw description from the brokerage. Potential values include - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getActivitiesRequest($user_id, $user_secret, $start_date = SENTINEL_VALUE, $end_date = SENTINEL_VALUE, $accounts = SENTINEL_VALUE, $brokerage_authorizations = SENTINEL_VALUE, $type = SENTINEL_VALUE, string $contentType = self::contentTypes['getActivities'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getActivities'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getActivities'
            );
        }
        // Check if $accounts is a string
        if ($accounts !== SENTINEL_VALUE && !is_string($accounts)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($accounts, true), gettype($accounts)));
        }
        // Check if $brokerage_authorizations is a string
        if ($brokerage_authorizations !== SENTINEL_VALUE && !is_string($brokerage_authorizations)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($brokerage_authorizations, true), gettype($brokerage_authorizations)));
        }
        // Check if $type is a string
        if ($type !== SENTINEL_VALUE && !is_string($type)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($type, true), gettype($type)));
        }


        $resourcePath = '/activities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($start_date !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $start_date,
                'startDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($end_date !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $end_date,
                'endDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($accounts !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $accounts,
                'accounts', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($brokerage_authorizations !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $brokerage_authorizations,
                'brokerageAuthorizations', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($type !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $type,
                'type', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getReportingCustomRange
     *
     * Get performance information for a specific timeframe
     *
     * @param  \DateTime $start_date start_date (required)
     * @param  \DateTime $end_date end_date (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  bool $detailed Optional, increases frequency of data points for the total value and contribution charts if set to true (optional)
     * @param  string $frequency Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReportingCustomRange'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PerformanceCustom
     * @deprecated
     */
    public function getReportingCustomRange(
        $start_date,
        $end_date,
        $user_id,
        $user_secret,
        $accounts = SENTINEL_VALUE,
        $detailed = SENTINEL_VALUE,
        $frequency = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getReportingCustomRange'][0]
    )
    {

        list($response) = $this->getReportingCustomRangeWithHttpInfo($start_date, $end_date, $user_id, $user_secret, $accounts, $detailed, $frequency, $contentType);
        return $response;
    }

    /**
     * Operation getReportingCustomRangeWithHttpInfo
     *
     * Get performance information for a specific timeframe
     *
     * @param  \DateTime $start_date (required)
     * @param  \DateTime $end_date (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  bool $detailed Optional, increases frequency of data points for the total value and contribution charts if set to true (optional)
     * @param  string $frequency Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReportingCustomRange'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PerformanceCustom, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getReportingCustomRangeWithHttpInfo($start_date, $end_date, $user_id, $user_secret, $accounts = null, $detailed = null, $frequency = null, string $contentType = self::contentTypes['getReportingCustomRange'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getReportingCustomRangeRequest($start_date, $end_date, $user_id, $user_secret, $accounts, $detailed, $frequency, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getReportingCustomRangeWithHttpInfo(
                        $start_date,
                        $end_date,
                        $user_id,
                        $user_secret,
                        $accounts,
                        $detailed,
                        $frequency,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PerformanceCustom' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PerformanceCustom' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PerformanceCustom', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PerformanceCustom';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PerformanceCustom',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportingCustomRangeAsync
     *
     * Get performance information for a specific timeframe
     *
     * @param  \DateTime $start_date (required)
     * @param  \DateTime $end_date (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  bool $detailed Optional, increases frequency of data points for the total value and contribution charts if set to true (optional)
     * @param  string $frequency Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReportingCustomRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getReportingCustomRangeAsync(
        $start_date,
        $end_date,
        $user_id,
        $user_secret,
        $accounts = SENTINEL_VALUE,
        $detailed = SENTINEL_VALUE,
        $frequency = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getReportingCustomRange'][0]
    )
    {

        return $this->getReportingCustomRangeAsyncWithHttpInfo($start_date, $end_date, $user_id, $user_secret, $accounts, $detailed, $frequency, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportingCustomRangeAsyncWithHttpInfo
     *
     * Get performance information for a specific timeframe
     *
     * @param  \DateTime $start_date (required)
     * @param  \DateTime $end_date (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  bool $detailed Optional, increases frequency of data points for the total value and contribution charts if set to true (optional)
     * @param  string $frequency Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReportingCustomRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getReportingCustomRangeAsyncWithHttpInfo($start_date, $end_date, $user_id, $user_secret, $accounts = null, $detailed = null, $frequency = null, string $contentType = self::contentTypes['getReportingCustomRange'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PerformanceCustom';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getReportingCustomRangeRequest($start_date, $end_date, $user_id, $user_secret, $accounts, $detailed, $frequency, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportingCustomRange'
     *
     * @param  \DateTime $start_date (required)
     * @param  \DateTime $end_date (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $accounts Optional comma seperated list of account IDs used to filter the request on specific accounts (optional)
     * @param  bool $detailed Optional, increases frequency of data points for the total value and contribution charts if set to true (optional)
     * @param  string $frequency Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReportingCustomRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getReportingCustomRangeRequest($start_date, $end_date, $user_id, $user_secret, $accounts = SENTINEL_VALUE, $detailed = SENTINEL_VALUE, $frequency = SENTINEL_VALUE, string $contentType = self::contentTypes['getReportingCustomRange'][0])
    {

        // verify the required parameter 'start_date' is set
        if ($start_date === SENTINEL_VALUE || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter start_date when calling getReportingCustomRange'
            );
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === SENTINEL_VALUE || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter end_date when calling getReportingCustomRange'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getReportingCustomRange'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getReportingCustomRange'
            );
        }
        // Check if $accounts is a string
        if ($accounts !== SENTINEL_VALUE && !is_string($accounts)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($accounts, true), gettype($accounts)));
        }
        // Check if $frequency is a string
        if ($frequency !== SENTINEL_VALUE && !is_string($frequency)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($frequency, true), gettype($frequency)));
        }


        $resourcePath = '/performance/custom';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($start_date !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $start_date,
                'startDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($end_date !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $end_date,
                'endDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($accounts !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $accounts,
                'accounts', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($detailed !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $detailed,
                'detailed', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($frequency !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $frequency,
                'frequency', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
