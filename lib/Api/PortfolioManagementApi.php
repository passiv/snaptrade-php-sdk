<?php
/**
 * PortfolioManagementApi
 * PHP version 7.4
 *
 * @category Class
 * @package  SnapTrade
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * SnapTrade
 *
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 * Generated by: https://konfigthis.com
 */


namespace SnapTrade\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use SnapTrade\ApiException;
use SnapTrade\Configuration;
use SnapTrade\HeaderSelector;
use SnapTrade\ObjectSerializer;

class PortfolioManagementApi extends \SnapTrade\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addPortfolioExcludedAsset' => [
            'application/json',
        ],
        'all' => [
            'application/json',
        ],
        'create' => [
            'application/json',
        ],
        'createAssetClass' => [
            'application/json',
        ],
        'createModelPortfolio' => [
            'application/json',
        ],
        'deleteAssetClass' => [
            'application/json',
        ],
        'deleteExcludedAsset' => [
            'application/json',
        ],
        'deleteModelPortfolioById' => [
            'application/json',
        ],
        'deletePortfoli' => [
            'application/json',
        ],
        'deletePortfolioTargetById' => [
            'application/json',
        ],
        'detailAssetClass' => [
            'application/json',
        ],
        'getCalculatedTradeById' => [
            'application/json',
        ],
        'getModelDetailsById' => [
            'application/json',
        ],
        'getPortfolioBalances' => [
            'application/json',
        ],
        'getPortfolioDetailsById' => [
            'application/json',
        ],
        'getPortfolioInfo' => [
            'application/json',
        ],
        'getPortfolioSettings' => [
            'application/json',
        ],
        'getPortfolioTargetById' => [
            'application/json',
        ],
        'getPortfolioTargets' => [
            'application/json',
        ],
        'getPortoflioExcludedAssets' => [
            'application/json',
        ],
        'importModelPortfolio' => [
            'application/json',
        ],
        'listAssetClasses' => [
            'application/json',
        ],
        'listCalculatedTrades' => [
            'application/json',
        ],
        'listModelPortfolio' => [
            'application/json',
        ],
        'listPortfolioAccounts' => [
            'application/json',
        ],
        'modifyModelPortfolioById' => [
            'application/json',
        ],
        'savePortfolio' => [
            'application/json',
        ],
        'searchPortfolioSymbols' => [
            'application/json',
        ],
        'setPortfolioTargets' => [
            'application/json',
        ],
        'updateAssetClass' => [
            'application/json',
        ],
        'updatePortfolioSettings' => [
            'application/json',
        ],
        'updatePortfolioTargetById' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;
        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation addPortfolioExcludedAsset
     *
     * Adds an asset to exclude to a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to exclude an asset. (required)
     * @param  \SnapTrade\Model\UniversalSymbol $universal_symbol universal_symbol (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPortfolioExcludedAsset'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ExcludedAsset
     */
    public function addPortfolioExcludedAsset(
        $portfolio_group_id,
        $id = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $raw_symbol = SENTINEL_VALUE,
        $description = SENTINEL_VALUE,
        $currency = SENTINEL_VALUE,
        $exchange = SENTINEL_VALUE,
        $type = SENTINEL_VALUE,
        $currencies = SENTINEL_VALUE,


        string $contentType = self::contentTypes['addPortfolioExcludedAsset'][0]

    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "raw_symbol", $raw_symbol);
        $this->setRequestBodyProperty($_body, "description", $description);
        $this->setRequestBodyProperty($_body, "currency", $currency);
        $this->setRequestBodyProperty($_body, "exchange", $exchange);
        $this->setRequestBodyProperty($_body, "type", $type);
        $this->setRequestBodyProperty($_body, "currencies", $currencies);
        $universal_symbol = $_body;

        list($response) = $this->addPortfolioExcludedAssetWithHttpInfo($portfolio_group_id, $universal_symbol, $contentType);
        return $response;
    }

    /**
     * Operation addPortfolioExcludedAssetWithHttpInfo
     *
     * Adds an asset to exclude to a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to exclude an asset. (required)
     * @param  \SnapTrade\Model\UniversalSymbol $universal_symbol (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPortfolioExcludedAsset'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ExcludedAsset, HTTP status code, HTTP response headers (array of strings)
     */
    public function addPortfolioExcludedAssetWithHttpInfo($portfolio_group_id, $universal_symbol = null, string $contentType = self::contentTypes['addPortfolioExcludedAsset'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->addPortfolioExcludedAssetRequest($portfolio_group_id, $universal_symbol, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->addPortfolioExcludedAssetWithHttpInfo(
                        $portfolio_group_id,
                        $universal_symbol,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ExcludedAsset' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ExcludedAsset' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ExcludedAsset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ExcludedAsset';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ExcludedAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addPortfolioExcludedAssetAsync
     *
     * Adds an asset to exclude to a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to exclude an asset. (required)
     * @param  \SnapTrade\Model\UniversalSymbol $universal_symbol (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPortfolioExcludedAsset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addPortfolioExcludedAssetAsync(
        $portfolio_group_id,
        $id = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $raw_symbol = SENTINEL_VALUE,
        $description = SENTINEL_VALUE,
        $currency = SENTINEL_VALUE,
        $exchange = SENTINEL_VALUE,
        $type = SENTINEL_VALUE,
        $currencies = SENTINEL_VALUE,


        string $contentType = self::contentTypes['addPortfolioExcludedAsset'][0]

    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "raw_symbol", $raw_symbol);
        $this->setRequestBodyProperty($_body, "description", $description);
        $this->setRequestBodyProperty($_body, "currency", $currency);
        $this->setRequestBodyProperty($_body, "exchange", $exchange);
        $this->setRequestBodyProperty($_body, "type", $type);
        $this->setRequestBodyProperty($_body, "currencies", $currencies);
        $universal_symbol = $_body;

        return $this->addPortfolioExcludedAssetAsyncWithHttpInfo($portfolio_group_id, $universal_symbol, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addPortfolioExcludedAssetAsyncWithHttpInfo
     *
     * Adds an asset to exclude to a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to exclude an asset. (required)
     * @param  \SnapTrade\Model\UniversalSymbol $universal_symbol (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPortfolioExcludedAsset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addPortfolioExcludedAssetAsyncWithHttpInfo($portfolio_group_id, $universal_symbol = null, string $contentType = self::contentTypes['addPortfolioExcludedAsset'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ExcludedAsset';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->addPortfolioExcludedAssetRequest($portfolio_group_id, $universal_symbol, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addPortfolioExcludedAsset'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to exclude an asset. (required)
     * @param  \SnapTrade\Model\UniversalSymbol $universal_symbol (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPortfolioExcludedAsset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addPortfolioExcludedAssetRequest($portfolio_group_id, $universal_symbol = SENTINEL_VALUE, string $contentType = self::contentTypes['addPortfolioExcludedAsset'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling addPortfolioExcludedAsset'
            );
        }
        if ($universal_symbol !== SENTINEL_VALUE) {
            if (!($universal_symbol instanceof \SnapTrade\Model\UniversalSymbol)) {
                if (!is_array($universal_symbol))
                    throw new \InvalidArgumentException('"universal_symbol" must be associative array or an instance of \SnapTrade\Model\UniversalSymbol PortfolioManagementApi.addPortfolioExcludedAsset.');
                else
                    $universal_symbol = new \SnapTrade\Model\UniversalSymbol($universal_symbol);
            }
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/excludedassets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($universal_symbol)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($universal_symbol));
            } else {
                $httpBody = $universal_symbol;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation all
     *
     * List all portfolio groups
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroup[]
     */
    public function all(
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['all'][0]

    )
    {

        list($response) = $this->allWithHttpInfo($user_id, $user_secret, $contentType);
        return $response;
    }

    /**
     * Operation allWithHttpInfo
     *
     * List all portfolio groups
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function allWithHttpInfo($user_id, $user_secret, string $contentType = self::contentTypes['all'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->allRequest($user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->allWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroup[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation allAsync
     *
     * List all portfolio groups
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allAsync(
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['all'][0]

    )
    {

        return $this->allAsyncWithHttpInfo($user_id, $user_secret, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation allAsyncWithHttpInfo
     *
     * List all portfolio groups
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allAsyncWithHttpInfo($user_id, $user_secret, string $contentType = self::contentTypes['all'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroup[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->allRequest($user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'all'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function allRequest($user_id, $user_secret, string $contentType = self::contentTypes['all'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling all'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling all'
            );
        }


        $resourcePath = '/portfolioGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation create
     *
     * Create new portfolio group
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  array<string,mixed> $request_body request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroup[]
     */
    public function create(

        $user_id,
        $user_secret,
        $id = SENTINEL_VALUE,
        $name = SENTINEL_VALUE,

        string $contentType = self::contentTypes['create'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "name", $name);
        $request_body = $_body;

        list($response) = $this->createWithHttpInfo($user_id, $user_secret, $request_body, $contentType);
        return $response;
    }

    /**
     * Operation createWithHttpInfo
     *
     * Create new portfolio group
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithHttpInfo($user_id, $user_secret, $request_body, string $contentType = self::contentTypes['create'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createRequest($user_id, $user_secret, $request_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->createWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $request_body,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroup[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAsync
     *
     * Create new portfolio group
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsync(

        $user_id,
        $user_secret,
        $id = SENTINEL_VALUE,
        $name = SENTINEL_VALUE,

        string $contentType = self::contentTypes['create'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "name", $name);
        $request_body = $_body;

        return $this->createAsyncWithHttpInfo($user_id, $user_secret, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAsyncWithHttpInfo
     *
     * Create new portfolio group
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsyncWithHttpInfo($user_id, $user_secret, $request_body, string $contentType = self::contentTypes['create'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroup[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createRequest($user_id, $user_secret, $request_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'create'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRequest($user_id, $user_secret, $request_body, string $contentType = self::contentTypes['create'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling create'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling create'
            );
        }
        // verify the required parameter 'request_body' is set
        if ($request_body === SENTINEL_VALUE || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter request_body when calling create'
            );
        }


        $resourcePath = '/portfolioGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation createAssetClass
     *
     * Create a new model asset class
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ModelAssetClassDetails
     */
    public function createAssetClass(
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['createAssetClass'][0]

    )
    {

        list($response) = $this->createAssetClassWithHttpInfo($user_id, $user_secret, $contentType);
        return $response;
    }

    /**
     * Operation createAssetClassWithHttpInfo
     *
     * Create a new model asset class
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ModelAssetClassDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAssetClassWithHttpInfo($user_id, $user_secret, string $contentType = self::contentTypes['createAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createAssetClassRequest($user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->createAssetClassWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ModelAssetClassDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ModelAssetClassDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ModelAssetClassDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ModelAssetClassDetails';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ModelAssetClassDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAssetClassAsync
     *
     * Create a new model asset class
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAssetClassAsync(
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['createAssetClass'][0]

    )
    {

        return $this->createAssetClassAsyncWithHttpInfo($user_id, $user_secret, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAssetClassAsyncWithHttpInfo
     *
     * Create a new model asset class
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAssetClassAsyncWithHttpInfo($user_id, $user_secret, string $contentType = self::contentTypes['createAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ModelAssetClassDetails';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createAssetClassRequest($user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAssetClass'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAssetClassRequest($user_id, $user_secret, string $contentType = self::contentTypes['createAssetClass'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling createAssetClass'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling createAssetClass'
            );
        }


        $resourcePath = '/modelAssetClass';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation createModelPortfolio
     *
     * Creates a new model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelPortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ModelPortfolioDetails
     */
    public function createModelPortfolio(


        string $contentType = self::contentTypes['createModelPortfolio'][0]

    )
    {

        list($response) = $this->createModelPortfolioWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation createModelPortfolioWithHttpInfo
     *
     * Creates a new model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelPortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ModelPortfolioDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModelPortfolioWithHttpInfo(string $contentType = self::contentTypes['createModelPortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createModelPortfolioRequest($contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->createModelPortfolioWithHttpInfo(
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ModelPortfolioDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ModelPortfolioDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ModelPortfolioDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ModelPortfolioDetails';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ModelPortfolioDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createModelPortfolioAsync
     *
     * Creates a new model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelPortfolioAsync(


        string $contentType = self::contentTypes['createModelPortfolio'][0]

    )
    {

        return $this->createModelPortfolioAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModelPortfolioAsyncWithHttpInfo
     *
     * Creates a new model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelPortfolioAsyncWithHttpInfo(string $contentType = self::contentTypes['createModelPortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ModelPortfolioDetails';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createModelPortfolioRequest($contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createModelPortfolio'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createModelPortfolioRequest(string $contentType = self::contentTypes['createModelPortfolio'][0])
    {



        $resourcePath = '/modelPortfolio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deleteAssetClass
     *
     * Deletes a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAssetClass(
        $model_asset_class_id,


        string $contentType = self::contentTypes['deleteAssetClass'][0]

    )
    {

        $this->deleteAssetClassWithHttpInfo($model_asset_class_id, $contentType);
    }

    /**
     * Operation deleteAssetClassWithHttpInfo
     *
     * Deletes a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAssetClassWithHttpInfo($model_asset_class_id, string $contentType = self::contentTypes['deleteAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteAssetClassRequest($model_asset_class_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteAssetClassWithHttpInfo(
                        $model_asset_class_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAssetClassAsync
     *
     * Deletes a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAssetClassAsync(
        $model_asset_class_id,


        string $contentType = self::contentTypes['deleteAssetClass'][0]

    )
    {

        return $this->deleteAssetClassAsyncWithHttpInfo($model_asset_class_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAssetClassAsyncWithHttpInfo
     *
     * Deletes a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAssetClassAsyncWithHttpInfo($model_asset_class_id, string $contentType = self::contentTypes['deleteAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteAssetClassRequest($model_asset_class_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAssetClass'
     *
     * @param  string $model_asset_class_id The ID of the model asset class to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAssetClassRequest($model_asset_class_id, string $contentType = self::contentTypes['deleteAssetClass'][0])
    {

        // Check if $model_asset_class_id is a string
        if ($model_asset_class_id !== SENTINEL_VALUE && !is_string($model_asset_class_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($model_asset_class_id, true), gettype($model_asset_class_id)));
        }
        // verify the required parameter 'model_asset_class_id' is set
        if ($model_asset_class_id === SENTINEL_VALUE || (is_array($model_asset_class_id) && count($model_asset_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_asset_class_id when calling deleteAssetClass'
            );
        }


        $resourcePath = '/modelAssetClass/{modelAssetClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($model_asset_class_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'modelAssetClassId' . '}',
                ObjectSerializer::toPathValue($model_asset_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'DELETE';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deleteExcludedAsset
     *
     * Unexclude an asset from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to unexclude an asset. (required)
     * @param  string $symbol_id The ID of the excluded asset Symbol to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExcludedAsset'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteExcludedAsset(
        $portfolio_group_id,
        $symbol_id,


        string $contentType = self::contentTypes['deleteExcludedAsset'][0]

    )
    {

        $this->deleteExcludedAssetWithHttpInfo($portfolio_group_id, $symbol_id, $contentType);
    }

    /**
     * Operation deleteExcludedAssetWithHttpInfo
     *
     * Unexclude an asset from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to unexclude an asset. (required)
     * @param  string $symbol_id The ID of the excluded asset Symbol to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExcludedAsset'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteExcludedAssetWithHttpInfo($portfolio_group_id, $symbol_id, string $contentType = self::contentTypes['deleteExcludedAsset'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteExcludedAssetRequest($portfolio_group_id, $symbol_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteExcludedAssetWithHttpInfo(
                        $portfolio_group_id,
                        $symbol_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteExcludedAssetAsync
     *
     * Unexclude an asset from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to unexclude an asset. (required)
     * @param  string $symbol_id The ID of the excluded asset Symbol to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExcludedAsset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExcludedAssetAsync(
        $portfolio_group_id,
        $symbol_id,


        string $contentType = self::contentTypes['deleteExcludedAsset'][0]

    )
    {

        return $this->deleteExcludedAssetAsyncWithHttpInfo($portfolio_group_id, $symbol_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteExcludedAssetAsyncWithHttpInfo
     *
     * Unexclude an asset from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to unexclude an asset. (required)
     * @param  string $symbol_id The ID of the excluded asset Symbol to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExcludedAsset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExcludedAssetAsyncWithHttpInfo($portfolio_group_id, $symbol_id, string $contentType = self::contentTypes['deleteExcludedAsset'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteExcludedAssetRequest($portfolio_group_id, $symbol_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteExcludedAsset'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to unexclude an asset. (required)
     * @param  string $symbol_id The ID of the excluded asset Symbol to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExcludedAsset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteExcludedAssetRequest($portfolio_group_id, $symbol_id, string $contentType = self::contentTypes['deleteExcludedAsset'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling deleteExcludedAsset'
            );
        }
        // Check if $symbol_id is a string
        if ($symbol_id !== SENTINEL_VALUE && !is_string($symbol_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($symbol_id, true), gettype($symbol_id)));
        }
        // verify the required parameter 'symbol_id' is set
        if ($symbol_id === SENTINEL_VALUE || (is_array($symbol_id) && count($symbol_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter symbol_id when calling deleteExcludedAsset'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/excludedassets/{symbolId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }
        // path params
        if ($symbol_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'symbolId' . '}',
                ObjectSerializer::toPathValue($symbol_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'DELETE';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deleteModelPortfolioById
     *
     * Deletes a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteModelPortfolioById(
        $model_portfolio_id,


        string $contentType = self::contentTypes['deleteModelPortfolioById'][0]

    )
    {

        $this->deleteModelPortfolioByIdWithHttpInfo($model_portfolio_id, $contentType);
    }

    /**
     * Operation deleteModelPortfolioByIdWithHttpInfo
     *
     * Deletes a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModelPortfolioByIdWithHttpInfo($model_portfolio_id, string $contentType = self::contentTypes['deleteModelPortfolioById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteModelPortfolioByIdRequest($model_portfolio_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteModelPortfolioByIdWithHttpInfo(
                        $model_portfolio_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteModelPortfolioByIdAsync
     *
     * Deletes a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModelPortfolioByIdAsync(
        $model_portfolio_id,


        string $contentType = self::contentTypes['deleteModelPortfolioById'][0]

    )
    {

        return $this->deleteModelPortfolioByIdAsyncWithHttpInfo($model_portfolio_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModelPortfolioByIdAsyncWithHttpInfo
     *
     * Deletes a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModelPortfolioByIdAsyncWithHttpInfo($model_portfolio_id, string $contentType = self::contentTypes['deleteModelPortfolioById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteModelPortfolioByIdRequest($model_portfolio_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModelPortfolioById'
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteModelPortfolioByIdRequest($model_portfolio_id, string $contentType = self::contentTypes['deleteModelPortfolioById'][0])
    {

        // Check if $model_portfolio_id is a string
        if ($model_portfolio_id !== SENTINEL_VALUE && !is_string($model_portfolio_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($model_portfolio_id, true), gettype($model_portfolio_id)));
        }
        // verify the required parameter 'model_portfolio_id' is set
        if ($model_portfolio_id === SENTINEL_VALUE || (is_array($model_portfolio_id) && count($model_portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_portfolio_id when calling deleteModelPortfolioById'
            );
        }


        $resourcePath = '/modelPortfolio/{modelPortfolioId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($model_portfolio_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'modelPortfolioId' . '}',
                ObjectSerializer::toPathValue($model_portfolio_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'DELETE';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deletePortfoli
     *
     * Remove a target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfoli'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroup
     */
    public function deletePortfoli(
        $portfolio_group_id,


        string $contentType = self::contentTypes['deletePortfoli'][0]

    )
    {

        list($response) = $this->deletePortfoliWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation deletePortfoliWithHttpInfo
     *
     * Remove a target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfoli'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePortfoliWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['deletePortfoli'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deletePortfoliRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deletePortfoliWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePortfoliAsync
     *
     * Remove a target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfoli'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePortfoliAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['deletePortfoli'][0]

    )
    {

        return $this->deletePortfoliAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePortfoliAsyncWithHttpInfo
     *
     * Remove a target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfoli'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePortfoliAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['deletePortfoli'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroup';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deletePortfoliRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePortfoli'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfoli'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePortfoliRequest($portfolio_group_id, string $contentType = self::contentTypes['deletePortfoli'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling deletePortfoli'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'DELETE';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deletePortfolioTargetById
     *
     * Remove a TargetAsset.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to remove the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TargetAsset
     */
    public function deletePortfolioTargetById(
        $portfolio_group_id,
        $target_asset_id,


        string $contentType = self::contentTypes['deletePortfolioTargetById'][0]

    )
    {

        list($response) = $this->deletePortfolioTargetByIdWithHttpInfo($portfolio_group_id, $target_asset_id, $contentType);
        return $response;
    }

    /**
     * Operation deletePortfolioTargetByIdWithHttpInfo
     *
     * Remove a TargetAsset.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to remove the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TargetAsset, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePortfolioTargetByIdWithHttpInfo($portfolio_group_id, $target_asset_id, string $contentType = self::contentTypes['deletePortfolioTargetById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deletePortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deletePortfolioTargetByIdWithHttpInfo(
                        $portfolio_group_id,
                        $target_asset_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TargetAsset' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TargetAsset' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TargetAsset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TargetAsset';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TargetAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePortfolioTargetByIdAsync
     *
     * Remove a TargetAsset.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to remove the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePortfolioTargetByIdAsync(
        $portfolio_group_id,
        $target_asset_id,


        string $contentType = self::contentTypes['deletePortfolioTargetById'][0]

    )
    {

        return $this->deletePortfolioTargetByIdAsyncWithHttpInfo($portfolio_group_id, $target_asset_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePortfolioTargetByIdAsyncWithHttpInfo
     *
     * Remove a TargetAsset.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to remove the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePortfolioTargetByIdAsyncWithHttpInfo($portfolio_group_id, $target_asset_id, string $contentType = self::contentTypes['deletePortfolioTargetById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TargetAsset';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deletePortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePortfolioTargetById'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to remove the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, string $contentType = self::contentTypes['deletePortfolioTargetById'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling deletePortfolioTargetById'
            );
        }
        // Check if $target_asset_id is a string
        if ($target_asset_id !== SENTINEL_VALUE && !is_string($target_asset_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($target_asset_id, true), gettype($target_asset_id)));
        }
        // verify the required parameter 'target_asset_id' is set
        if ($target_asset_id === SENTINEL_VALUE || (is_array($target_asset_id) && count($target_asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter target_asset_id when calling deletePortfolioTargetById'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }
        // path params
        if ($target_asset_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'targetAssetId' . '}',
                ObjectSerializer::toPathValue($target_asset_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'DELETE';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation detailAssetClass
     *
     * Get details of a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to get. (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['detailAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ModelAssetClassDetails
     */
    public function detailAssetClass(
        $model_asset_class_id,
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['detailAssetClass'][0]

    )
    {

        list($response) = $this->detailAssetClassWithHttpInfo($model_asset_class_id, $user_id, $user_secret, $contentType);
        return $response;
    }

    /**
     * Operation detailAssetClassWithHttpInfo
     *
     * Get details of a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to get. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['detailAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ModelAssetClassDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function detailAssetClassWithHttpInfo($model_asset_class_id, $user_id, $user_secret, string $contentType = self::contentTypes['detailAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->detailAssetClassRequest($model_asset_class_id, $user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->detailAssetClassWithHttpInfo(
                        $model_asset_class_id,
                        $user_id,
                        $user_secret,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ModelAssetClassDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ModelAssetClassDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ModelAssetClassDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ModelAssetClassDetails';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ModelAssetClassDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detailAssetClassAsync
     *
     * Get details of a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to get. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['detailAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detailAssetClassAsync(
        $model_asset_class_id,
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['detailAssetClass'][0]

    )
    {

        return $this->detailAssetClassAsyncWithHttpInfo($model_asset_class_id, $user_id, $user_secret, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detailAssetClassAsyncWithHttpInfo
     *
     * Get details of a model asset class
     *
     * @param  string $model_asset_class_id The ID of the model asset class to get. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['detailAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detailAssetClassAsyncWithHttpInfo($model_asset_class_id, $user_id, $user_secret, string $contentType = self::contentTypes['detailAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ModelAssetClassDetails';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->detailAssetClassRequest($model_asset_class_id, $user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detailAssetClass'
     *
     * @param  string $model_asset_class_id The ID of the model asset class to get. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['detailAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function detailAssetClassRequest($model_asset_class_id, $user_id, $user_secret, string $contentType = self::contentTypes['detailAssetClass'][0])
    {

        // Check if $model_asset_class_id is a string
        if ($model_asset_class_id !== SENTINEL_VALUE && !is_string($model_asset_class_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($model_asset_class_id, true), gettype($model_asset_class_id)));
        }
        // verify the required parameter 'model_asset_class_id' is set
        if ($model_asset_class_id === SENTINEL_VALUE || (is_array($model_asset_class_id) && count($model_asset_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_asset_class_id when calling detailAssetClass'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling detailAssetClass'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling detailAssetClass'
            );
        }


        $resourcePath = '/modelAssetClass/{modelAssetClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($model_asset_class_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'modelAssetClassId' . '}',
                ObjectSerializer::toPathValue($model_asset_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getCalculatedTradeById
     *
     * Return an individual trade
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $calculated_trade_id The ID of calculated trade to get account impact (required)
     * @param  string $trade_id The ID of trade object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalculatedTradeById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\Trade[]
     */
    public function getCalculatedTradeById(
        $portfolio_group_id,
        $calculated_trade_id,
        $trade_id,


        string $contentType = self::contentTypes['getCalculatedTradeById'][0]

    )
    {

        list($response) = $this->getCalculatedTradeByIdWithHttpInfo($portfolio_group_id, $calculated_trade_id, $trade_id, $contentType);
        return $response;
    }

    /**
     * Operation getCalculatedTradeByIdWithHttpInfo
     *
     * Return an individual trade
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $calculated_trade_id The ID of calculated trade to get account impact (required)
     * @param  string $trade_id The ID of trade object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalculatedTradeById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\Trade[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCalculatedTradeByIdWithHttpInfo($portfolio_group_id, $calculated_trade_id, $trade_id, string $contentType = self::contentTypes['getCalculatedTradeById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getCalculatedTradeByIdRequest($portfolio_group_id, $calculated_trade_id, $trade_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getCalculatedTradeByIdWithHttpInfo(
                        $portfolio_group_id,
                        $calculated_trade_id,
                        $trade_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\Trade[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Trade[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Trade[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\Trade[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Trade[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCalculatedTradeByIdAsync
     *
     * Return an individual trade
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $calculated_trade_id The ID of calculated trade to get account impact (required)
     * @param  string $trade_id The ID of trade object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalculatedTradeById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCalculatedTradeByIdAsync(
        $portfolio_group_id,
        $calculated_trade_id,
        $trade_id,


        string $contentType = self::contentTypes['getCalculatedTradeById'][0]

    )
    {

        return $this->getCalculatedTradeByIdAsyncWithHttpInfo($portfolio_group_id, $calculated_trade_id, $trade_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCalculatedTradeByIdAsyncWithHttpInfo
     *
     * Return an individual trade
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $calculated_trade_id The ID of calculated trade to get account impact (required)
     * @param  string $trade_id The ID of trade object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalculatedTradeById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCalculatedTradeByIdAsyncWithHttpInfo($portfolio_group_id, $calculated_trade_id, $trade_id, string $contentType = self::contentTypes['getCalculatedTradeById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\Trade[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getCalculatedTradeByIdRequest($portfolio_group_id, $calculated_trade_id, $trade_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCalculatedTradeById'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $calculated_trade_id The ID of calculated trade to get account impact (required)
     * @param  string $trade_id The ID of trade object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalculatedTradeById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCalculatedTradeByIdRequest($portfolio_group_id, $calculated_trade_id, $trade_id, string $contentType = self::contentTypes['getCalculatedTradeById'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getCalculatedTradeById'
            );
        }
        // Check if $calculated_trade_id is a string
        if ($calculated_trade_id !== SENTINEL_VALUE && !is_string($calculated_trade_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($calculated_trade_id, true), gettype($calculated_trade_id)));
        }
        // verify the required parameter 'calculated_trade_id' is set
        if ($calculated_trade_id === SENTINEL_VALUE || (is_array($calculated_trade_id) && count($calculated_trade_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter calculated_trade_id when calling getCalculatedTradeById'
            );
        }
        // Check if $trade_id is a string
        if ($trade_id !== SENTINEL_VALUE && !is_string($trade_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($trade_id, true), gettype($trade_id)));
        }
        // verify the required parameter 'trade_id' is set
        if ($trade_id === SENTINEL_VALUE || (is_array($trade_id) && count($trade_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter trade_id when calling getCalculatedTradeById'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/{TradeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }
        // path params
        if ($calculated_trade_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'calculatedTradeId' . '}',
                ObjectSerializer::toPathValue($calculated_trade_id),
                $resourcePath
            );
        }
        // path params
        if ($trade_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'TradeId' . '}',
                ObjectSerializer::toPathValue($trade_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getModelDetailsById
     *
     * Get details of a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelDetailsById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ModelPortfolioDetails
     */
    public function getModelDetailsById(
        $model_portfolio_id,


        string $contentType = self::contentTypes['getModelDetailsById'][0]

    )
    {

        list($response) = $this->getModelDetailsByIdWithHttpInfo($model_portfolio_id, $contentType);
        return $response;
    }

    /**
     * Operation getModelDetailsByIdWithHttpInfo
     *
     * Get details of a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelDetailsById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ModelPortfolioDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModelDetailsByIdWithHttpInfo($model_portfolio_id, string $contentType = self::contentTypes['getModelDetailsById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getModelDetailsByIdRequest($model_portfolio_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getModelDetailsByIdWithHttpInfo(
                        $model_portfolio_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ModelPortfolioDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ModelPortfolioDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ModelPortfolioDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ModelPortfolioDetails';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ModelPortfolioDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModelDetailsByIdAsync
     *
     * Get details of a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelDetailsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelDetailsByIdAsync(
        $model_portfolio_id,


        string $contentType = self::contentTypes['getModelDetailsById'][0]

    )
    {

        return $this->getModelDetailsByIdAsyncWithHttpInfo($model_portfolio_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModelDetailsByIdAsyncWithHttpInfo
     *
     * Get details of a model portfolio
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelDetailsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelDetailsByIdAsyncWithHttpInfo($model_portfolio_id, string $contentType = self::contentTypes['getModelDetailsById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ModelPortfolioDetails';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getModelDetailsByIdRequest($model_portfolio_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModelDetailsById'
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelDetailsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getModelDetailsByIdRequest($model_portfolio_id, string $contentType = self::contentTypes['getModelDetailsById'][0])
    {

        // Check if $model_portfolio_id is a string
        if ($model_portfolio_id !== SENTINEL_VALUE && !is_string($model_portfolio_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($model_portfolio_id, true), gettype($model_portfolio_id)));
        }
        // verify the required parameter 'model_portfolio_id' is set
        if ($model_portfolio_id === SENTINEL_VALUE || (is_array($model_portfolio_id) && count($model_portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_portfolio_id when calling getModelDetailsById'
            );
        }


        $resourcePath = '/modelPortfolio/{modelPortfolioId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($model_portfolio_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'modelPortfolioId' . '}',
                ObjectSerializer::toPathValue($model_portfolio_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortfolioBalances
     *
     * Get sum of cash balances in portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioBalances'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\Balance[]
     */
    public function getPortfolioBalances(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioBalances'][0]

    )
    {

        list($response) = $this->getPortfolioBalancesWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortfolioBalancesWithHttpInfo
     *
     * Get sum of cash balances in portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioBalances'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\Balance[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortfolioBalancesWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioBalances'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioBalancesRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortfolioBalancesWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\Balance[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Balance[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Balance[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\Balance[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Balance[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortfolioBalancesAsync
     *
     * Get sum of cash balances in portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioBalancesAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioBalances'][0]

    )
    {

        return $this->getPortfolioBalancesAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortfolioBalancesAsyncWithHttpInfo
     *
     * Get sum of cash balances in portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioBalancesAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioBalances'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\Balance[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioBalancesRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortfolioBalances'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortfolioBalancesRequest($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioBalances'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortfolioBalances'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/balances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortfolioDetailsById
     *
     * Get details of a target portfolio
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioDetailsById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroup
     */
    public function getPortfolioDetailsById(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioDetailsById'][0]

    )
    {

        list($response) = $this->getPortfolioDetailsByIdWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortfolioDetailsByIdWithHttpInfo
     *
     * Get details of a target portfolio
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioDetailsById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortfolioDetailsByIdWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioDetailsById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioDetailsByIdRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortfolioDetailsByIdWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortfolioDetailsByIdAsync
     *
     * Get details of a target portfolio
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioDetailsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioDetailsByIdAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioDetailsById'][0]

    )
    {

        return $this->getPortfolioDetailsByIdAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortfolioDetailsByIdAsyncWithHttpInfo
     *
     * Get details of a target portfolio
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioDetailsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioDetailsByIdAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioDetailsById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroup';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioDetailsByIdRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortfolioDetailsById'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioDetailsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortfolioDetailsByIdRequest($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioDetailsById'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortfolioDetailsById'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortfolioInfo
     *
     * Return a whole bunch of relevant information relating to a portfolio group.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioInfo'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroupInfo
     */
    public function getPortfolioInfo(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioInfo'][0]

    )
    {

        list($response) = $this->getPortfolioInfoWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortfolioInfoWithHttpInfo
     *
     * Return a whole bunch of relevant information relating to a portfolio group.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioInfo'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroupInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortfolioInfoWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioInfo'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioInfoRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortfolioInfoWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroupInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroupInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroupInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroupInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroupInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortfolioInfoAsync
     *
     * Return a whole bunch of relevant information relating to a portfolio group.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioInfoAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioInfo'][0]

    )
    {

        return $this->getPortfolioInfoAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortfolioInfoAsyncWithHttpInfo
     *
     * Return a whole bunch of relevant information relating to a portfolio group.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioInfoAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioInfo'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroupInfo';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioInfoRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortfolioInfo'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortfolioInfoRequest($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioInfo'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortfolioInfo'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortfolioSettings
     *
     * Get portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioSettings'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroupSettings
     */
    public function getPortfolioSettings(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioSettings'][0]

    )
    {

        list($response) = $this->getPortfolioSettingsWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortfolioSettingsWithHttpInfo
     *
     * Get portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioSettings'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroupSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortfolioSettingsWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioSettings'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioSettingsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortfolioSettingsWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroupSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroupSettings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroupSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroupSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroupSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortfolioSettingsAsync
     *
     * Get portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioSettingsAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioSettings'][0]

    )
    {

        return $this->getPortfolioSettingsAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortfolioSettingsAsyncWithHttpInfo
     *
     * Get portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioSettingsAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioSettings'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroupSettings';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioSettingsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortfolioSettings'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortfolioSettingsRequest($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioSettings'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortfolioSettings'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortfolioTargetById
     *
     * Get a specific target from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TargetAsset
     */
    public function getPortfolioTargetById(
        $portfolio_group_id,
        $target_asset_id,


        string $contentType = self::contentTypes['getPortfolioTargetById'][0]

    )
    {

        list($response) = $this->getPortfolioTargetByIdWithHttpInfo($portfolio_group_id, $target_asset_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortfolioTargetByIdWithHttpInfo
     *
     * Get a specific target from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TargetAsset, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortfolioTargetByIdWithHttpInfo($portfolio_group_id, $target_asset_id, string $contentType = self::contentTypes['getPortfolioTargetById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortfolioTargetByIdWithHttpInfo(
                        $portfolio_group_id,
                        $target_asset_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TargetAsset' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TargetAsset' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TargetAsset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TargetAsset';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TargetAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortfolioTargetByIdAsync
     *
     * Get a specific target from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioTargetByIdAsync(
        $portfolio_group_id,
        $target_asset_id,


        string $contentType = self::contentTypes['getPortfolioTargetById'][0]

    )
    {

        return $this->getPortfolioTargetByIdAsyncWithHttpInfo($portfolio_group_id, $target_asset_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortfolioTargetByIdAsyncWithHttpInfo
     *
     * Get a specific target from a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioTargetByIdAsyncWithHttpInfo($portfolio_group_id, $target_asset_id, string $contentType = self::contentTypes['getPortfolioTargetById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TargetAsset';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortfolioTargetById'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to get the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, string $contentType = self::contentTypes['getPortfolioTargetById'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortfolioTargetById'
            );
        }
        // Check if $target_asset_id is a string
        if ($target_asset_id !== SENTINEL_VALUE && !is_string($target_asset_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($target_asset_id, true), gettype($target_asset_id)));
        }
        // verify the required parameter 'target_asset_id' is set
        if ($target_asset_id === SENTINEL_VALUE || (is_array($target_asset_id) && count($target_asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter target_asset_id when calling getPortfolioTargetById'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }
        // path params
        if ($target_asset_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'targetAssetId' . '}',
                ObjectSerializer::toPathValue($target_asset_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortfolioTargets
     *
     * Get all target assets under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TargetAsset[]
     */
    public function getPortfolioTargets(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioTargets'][0]

    )
    {

        list($response) = $this->getPortfolioTargetsWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortfolioTargetsWithHttpInfo
     *
     * Get all target assets under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TargetAsset[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortfolioTargetsWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioTargets'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioTargetsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortfolioTargetsWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TargetAsset[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TargetAsset[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TargetAsset[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TargetAsset[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TargetAsset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortfolioTargetsAsync
     *
     * Get all target assets under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioTargetsAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortfolioTargets'][0]

    )
    {

        return $this->getPortfolioTargetsAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortfolioTargetsAsyncWithHttpInfo
     *
     * Get all target assets under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortfolioTargetsAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioTargets'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TargetAsset[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortfolioTargetsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortfolioTargets'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortfolioTargetsRequest($portfolio_group_id, string $contentType = self::contentTypes['getPortfolioTargets'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortfolioTargets'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/targets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getPortoflioExcludedAssets
     *
     * Get an array of excluded assets associated with a portfolio group\\
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the excluded assets are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortoflioExcludedAssets'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ExcludedAsset[]
     */
    public function getPortoflioExcludedAssets(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortoflioExcludedAssets'][0]

    )
    {

        list($response) = $this->getPortoflioExcludedAssetsWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation getPortoflioExcludedAssetsWithHttpInfo
     *
     * Get an array of excluded assets associated with a portfolio group\\
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the excluded assets are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortoflioExcludedAssets'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ExcludedAsset[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortoflioExcludedAssetsWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortoflioExcludedAssets'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortoflioExcludedAssetsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getPortoflioExcludedAssetsWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ExcludedAsset[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ExcludedAsset[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ExcludedAsset[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ExcludedAsset[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ExcludedAsset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPortoflioExcludedAssetsAsync
     *
     * Get an array of excluded assets associated with a portfolio group\\
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the excluded assets are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortoflioExcludedAssets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortoflioExcludedAssetsAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['getPortoflioExcludedAssets'][0]

    )
    {

        return $this->getPortoflioExcludedAssetsAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortoflioExcludedAssetsAsyncWithHttpInfo
     *
     * Get an array of excluded assets associated with a portfolio group\\
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the excluded assets are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortoflioExcludedAssets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortoflioExcludedAssetsAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['getPortoflioExcludedAssets'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ExcludedAsset[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getPortoflioExcludedAssetsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortoflioExcludedAssets'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the excluded assets are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortoflioExcludedAssets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortoflioExcludedAssetsRequest($portfolio_group_id, string $contentType = self::contentTypes['getPortoflioExcludedAssets'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling getPortoflioExcludedAssets'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/excludedassets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation importModelPortfolio
     *
     * Import target allocation based on portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importModelPortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TargetAsset[]
     */
    public function importModelPortfolio(
        $portfolio_group_id,


        string $contentType = self::contentTypes['importModelPortfolio'][0]

    )
    {

        list($response) = $this->importModelPortfolioWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation importModelPortfolioWithHttpInfo
     *
     * Import target allocation based on portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importModelPortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TargetAsset[], HTTP status code, HTTP response headers (array of strings)
     */
    public function importModelPortfolioWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['importModelPortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->importModelPortfolioRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->importModelPortfolioWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TargetAsset[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TargetAsset[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TargetAsset[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TargetAsset[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TargetAsset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importModelPortfolioAsync
     *
     * Import target allocation based on portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importModelPortfolioAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['importModelPortfolio'][0]

    )
    {

        return $this->importModelPortfolioAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importModelPortfolioAsyncWithHttpInfo
     *
     * Import target allocation based on portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importModelPortfolioAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['importModelPortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TargetAsset[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->importModelPortfolioRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importModelPortfolio'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importModelPortfolioRequest($portfolio_group_id, string $contentType = self::contentTypes['importModelPortfolio'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling importModelPortfolio'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation listAssetClasses
     *
     * List of model asset class
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAssetClasses'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ModelAssetClassDetails[]
     */
    public function listAssetClasses(
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['listAssetClasses'][0]

    )
    {

        list($response) = $this->listAssetClassesWithHttpInfo($user_id, $user_secret, $contentType);
        return $response;
    }

    /**
     * Operation listAssetClassesWithHttpInfo
     *
     * List of model asset class
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAssetClasses'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ModelAssetClassDetails[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listAssetClassesWithHttpInfo($user_id, $user_secret, string $contentType = self::contentTypes['listAssetClasses'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listAssetClassesRequest($user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->listAssetClassesWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ModelAssetClassDetails[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ModelAssetClassDetails[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ModelAssetClassDetails[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ModelAssetClassDetails[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ModelAssetClassDetails[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAssetClassesAsync
     *
     * List of model asset class
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAssetClasses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAssetClassesAsync(
        $user_id,
        $user_secret,


        string $contentType = self::contentTypes['listAssetClasses'][0]

    )
    {

        return $this->listAssetClassesAsyncWithHttpInfo($user_id, $user_secret, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAssetClassesAsyncWithHttpInfo
     *
     * List of model asset class
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAssetClasses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAssetClassesAsyncWithHttpInfo($user_id, $user_secret, string $contentType = self::contentTypes['listAssetClasses'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ModelAssetClassDetails[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listAssetClassesRequest($user_id, $user_secret, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAssetClasses'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAssetClasses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAssetClassesRequest($user_id, $user_secret, string $contentType = self::contentTypes['listAssetClasses'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling listAssetClasses'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling listAssetClasses'
            );
        }


        $resourcePath = '/modelAssetClass';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation listCalculatedTrades
     *
     * List of trades to make to rebalance portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalculatedTrades'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\CalculatedTrade
     */
    public function listCalculatedTrades(
        $portfolio_group_id,


        string $contentType = self::contentTypes['listCalculatedTrades'][0]

    )
    {

        list($response) = $this->listCalculatedTradesWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation listCalculatedTradesWithHttpInfo
     *
     * List of trades to make to rebalance portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalculatedTrades'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\CalculatedTrade, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCalculatedTradesWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['listCalculatedTrades'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listCalculatedTradesRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->listCalculatedTradesWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\CalculatedTrade' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\CalculatedTrade' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\CalculatedTrade', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\CalculatedTrade';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\CalculatedTrade',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCalculatedTradesAsync
     *
     * List of trades to make to rebalance portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalculatedTrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCalculatedTradesAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['listCalculatedTrades'][0]

    )
    {

        return $this->listCalculatedTradesAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCalculatedTradesAsyncWithHttpInfo
     *
     * List of trades to make to rebalance portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalculatedTrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCalculatedTradesAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['listCalculatedTrades'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\CalculatedTrade';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listCalculatedTradesRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCalculatedTrades'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to perform rebalancing calculations (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalculatedTrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCalculatedTradesRequest($portfolio_group_id, string $contentType = self::contentTypes['listCalculatedTrades'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling listCalculatedTrades'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/calculatedtrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation listModelPortfolio
     *
     * List of model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModelPortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ModelPortfolioDetails[]
     */
    public function listModelPortfolio(


        string $contentType = self::contentTypes['listModelPortfolio'][0]

    )
    {

        list($response) = $this->listModelPortfolioWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listModelPortfolioWithHttpInfo
     *
     * List of model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModelPortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ModelPortfolioDetails[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listModelPortfolioWithHttpInfo(string $contentType = self::contentTypes['listModelPortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listModelPortfolioRequest($contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->listModelPortfolioWithHttpInfo(
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ModelPortfolioDetails[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ModelPortfolioDetails[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ModelPortfolioDetails[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ModelPortfolioDetails[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ModelPortfolioDetails[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listModelPortfolioAsync
     *
     * List of model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModelPortfolioAsync(


        string $contentType = self::contentTypes['listModelPortfolio'][0]

    )
    {

        return $this->listModelPortfolioAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listModelPortfolioAsyncWithHttpInfo
     *
     * List of model portfolio
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModelPortfolioAsyncWithHttpInfo(string $contentType = self::contentTypes['listModelPortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ModelPortfolioDetails[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listModelPortfolioRequest($contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listModelPortfolio'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModelPortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listModelPortfolioRequest(string $contentType = self::contentTypes['listModelPortfolio'][0])
    {



        $resourcePath = '/modelPortfolio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation listPortfolioAccounts
     *
     * Get all accounts associated with a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the accounts are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPortfolioAccounts'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\Account[]
     */
    public function listPortfolioAccounts(
        $portfolio_group_id,


        string $contentType = self::contentTypes['listPortfolioAccounts'][0]

    )
    {

        list($response) = $this->listPortfolioAccountsWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation listPortfolioAccountsWithHttpInfo
     *
     * Get all accounts associated with a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the accounts are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPortfolioAccounts'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\Account[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listPortfolioAccountsWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['listPortfolioAccounts'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listPortfolioAccountsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->listPortfolioAccountsWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\Account[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Account[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Account[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\Account[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Account[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPortfolioAccountsAsync
     *
     * Get all accounts associated with a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the accounts are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPortfolioAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPortfolioAccountsAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['listPortfolioAccounts'][0]

    )
    {

        return $this->listPortfolioAccountsAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPortfolioAccountsAsyncWithHttpInfo
     *
     * Get all accounts associated with a portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the accounts are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPortfolioAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPortfolioAccountsAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['listPortfolioAccounts'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\Account[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->listPortfolioAccountsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPortfolioAccounts'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which the accounts are linked. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPortfolioAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPortfolioAccountsRequest($portfolio_group_id, string $contentType = self::contentTypes['listPortfolioAccounts'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling listPortfolioAccounts'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation modifyModelPortfolioById
     *
     * Updates model portfolio object
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to update. (required)
     * @param  \SnapTrade\Model\ModelPortfolioDetails $model_portfolio_details Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modifyModelPortfolioById(

        $model_portfolio_id,
        $model_portfolio = SENTINEL_VALUE,
        $model_portfolio_security = SENTINEL_VALUE,
        $model_portfolio_asset_class = SENTINEL_VALUE,

        string $contentType = self::contentTypes['modifyModelPortfolioById'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "model_portfolio", $model_portfolio);
        $this->setRequestBodyProperty($_body, "model_portfolio_security", $model_portfolio_security);
        $this->setRequestBodyProperty($_body, "model_portfolio_asset_class", $model_portfolio_asset_class);
        $model_portfolio_details = $_body;

        $this->modifyModelPortfolioByIdWithHttpInfo($model_portfolio_id, $model_portfolio_details, $contentType);
    }

    /**
     * Operation modifyModelPortfolioByIdWithHttpInfo
     *
     * Updates model portfolio object
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to update. (required)
     * @param  \SnapTrade\Model\ModelPortfolioDetails $model_portfolio_details Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyModelPortfolioByIdWithHttpInfo($model_portfolio_id, $model_portfolio_details, string $contentType = self::contentTypes['modifyModelPortfolioById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->modifyModelPortfolioByIdRequest($model_portfolio_id, $model_portfolio_details, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->modifyModelPortfolioByIdWithHttpInfo(
                        $model_portfolio_id,
                        $model_portfolio_details,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation modifyModelPortfolioByIdAsync
     *
     * Updates model portfolio object
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to update. (required)
     * @param  \SnapTrade\Model\ModelPortfolioDetails $model_portfolio_details Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyModelPortfolioByIdAsync(

        $model_portfolio_id,
        $model_portfolio = SENTINEL_VALUE,
        $model_portfolio_security = SENTINEL_VALUE,
        $model_portfolio_asset_class = SENTINEL_VALUE,

        string $contentType = self::contentTypes['modifyModelPortfolioById'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "model_portfolio", $model_portfolio);
        $this->setRequestBodyProperty($_body, "model_portfolio_security", $model_portfolio_security);
        $this->setRequestBodyProperty($_body, "model_portfolio_asset_class", $model_portfolio_asset_class);
        $model_portfolio_details = $_body;

        return $this->modifyModelPortfolioByIdAsyncWithHttpInfo($model_portfolio_id, $model_portfolio_details, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyModelPortfolioByIdAsyncWithHttpInfo
     *
     * Updates model portfolio object
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to update. (required)
     * @param  \SnapTrade\Model\ModelPortfolioDetails $model_portfolio_details Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyModelPortfolioByIdAsyncWithHttpInfo($model_portfolio_id, $model_portfolio_details, string $contentType = self::contentTypes['modifyModelPortfolioById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->modifyModelPortfolioByIdRequest($model_portfolio_id, $model_portfolio_details, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyModelPortfolioById'
     *
     * @param  string $model_portfolio_id The ID of the model portfolio to update. (required)
     * @param  \SnapTrade\Model\ModelPortfolioDetails $model_portfolio_details Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyModelPortfolioById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modifyModelPortfolioByIdRequest($model_portfolio_id, $model_portfolio_details, string $contentType = self::contentTypes['modifyModelPortfolioById'][0])
    {

        // Check if $model_portfolio_id is a string
        if ($model_portfolio_id !== SENTINEL_VALUE && !is_string($model_portfolio_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($model_portfolio_id, true), gettype($model_portfolio_id)));
        }
        // verify the required parameter 'model_portfolio_id' is set
        if ($model_portfolio_id === SENTINEL_VALUE || (is_array($model_portfolio_id) && count($model_portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_portfolio_id when calling modifyModelPortfolioById'
            );
        }
        if ($model_portfolio_details !== SENTINEL_VALUE) {
            if (!($model_portfolio_details instanceof \SnapTrade\Model\ModelPortfolioDetails)) {
                if (!is_array($model_portfolio_details))
                    throw new \InvalidArgumentException('"model_portfolio_details" must be associative array or an instance of \SnapTrade\Model\ModelPortfolioDetails PortfolioManagementApi.modifyModelPortfolioById.');
                else
                    $model_portfolio_details = new \SnapTrade\Model\ModelPortfolioDetails($model_portfolio_details);
            }
        }
        // verify the required parameter 'model_portfolio_details' is set
        if ($model_portfolio_details === SENTINEL_VALUE || (is_array($model_portfolio_details) && count($model_portfolio_details) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_portfolio_details when calling modifyModelPortfolioById'
            );
        }


        $resourcePath = '/modelPortfolio/{modelPortfolioId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($model_portfolio_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'modelPortfolioId' . '}',
                ObjectSerializer::toPathValue($model_portfolio_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($model_portfolio_details)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($model_portfolio_details));
            } else {
                $httpBody = $model_portfolio_details;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation savePortfolio
     *
     * Update an existing target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to update. (required)
     * @param  array<string,mixed> $request_body request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroup
     */
    public function savePortfolio(

        $portfolio_group_id,
        $id = SENTINEL_VALUE,
        $name = SENTINEL_VALUE,

        string $contentType = self::contentTypes['savePortfolio'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "name", $name);
        $request_body = $_body;

        list($response) = $this->savePortfolioWithHttpInfo($portfolio_group_id, $request_body, $contentType);
        return $response;
    }

    /**
     * Operation savePortfolioWithHttpInfo
     *
     * Update an existing target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to update. (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortfolio'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function savePortfolioWithHttpInfo($portfolio_group_id, $request_body, string $contentType = self::contentTypes['savePortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->savePortfolioRequest($portfolio_group_id, $request_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->savePortfolioWithHttpInfo(
                        $portfolio_group_id,
                        $request_body,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation savePortfolioAsync
     *
     * Update an existing target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to update. (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function savePortfolioAsync(

        $portfolio_group_id,
        $id = SENTINEL_VALUE,
        $name = SENTINEL_VALUE,

        string $contentType = self::contentTypes['savePortfolio'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "name", $name);
        $request_body = $_body;

        return $this->savePortfolioAsyncWithHttpInfo($portfolio_group_id, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation savePortfolioAsyncWithHttpInfo
     *
     * Update an existing target portfolio.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to update. (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function savePortfolioAsyncWithHttpInfo($portfolio_group_id, $request_body, string $contentType = self::contentTypes['savePortfolio'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroup';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->savePortfolioRequest($portfolio_group_id, $request_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'savePortfolio'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to update. (required)
     * @param  array<string,mixed> $request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortfolio'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function savePortfolioRequest($portfolio_group_id, $request_body, string $contentType = self::contentTypes['savePortfolio'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling savePortfolio'
            );
        }
        // verify the required parameter 'request_body' is set
        if ($request_body === SENTINEL_VALUE || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter request_body when calling savePortfolio'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'PATCH';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation searchPortfolioSymbols
     *
     * Search for symbols limited to brokerages under the specified portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to search under (required)
     * @param  \SnapTrade\Model\SymbolQuery $symbol_query symbol_query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPortfolioSymbols'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\UniversalSymbol[]
     */
    public function searchPortfolioSymbols(
        $portfolio_group_id,
        $substring = SENTINEL_VALUE,


        string $contentType = self::contentTypes['searchPortfolioSymbols'][0]

    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "substring", $substring);
        $symbol_query = $_body;

        list($response) = $this->searchPortfolioSymbolsWithHttpInfo($portfolio_group_id, $symbol_query, $contentType);
        return $response;
    }

    /**
     * Operation searchPortfolioSymbolsWithHttpInfo
     *
     * Search for symbols limited to brokerages under the specified portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to search under (required)
     * @param  \SnapTrade\Model\SymbolQuery $symbol_query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPortfolioSymbols'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\UniversalSymbol[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPortfolioSymbolsWithHttpInfo($portfolio_group_id, $symbol_query = null, string $contentType = self::contentTypes['searchPortfolioSymbols'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->searchPortfolioSymbolsRequest($portfolio_group_id, $symbol_query, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->searchPortfolioSymbolsWithHttpInfo(
                        $portfolio_group_id,
                        $symbol_query,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\UniversalSymbol[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\UniversalSymbol[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\UniversalSymbol[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\UniversalSymbol[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\UniversalSymbol[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchPortfolioSymbolsAsync
     *
     * Search for symbols limited to brokerages under the specified portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to search under (required)
     * @param  \SnapTrade\Model\SymbolQuery $symbol_query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPortfolioSymbols'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPortfolioSymbolsAsync(
        $portfolio_group_id,
        $substring = SENTINEL_VALUE,


        string $contentType = self::contentTypes['searchPortfolioSymbols'][0]

    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "substring", $substring);
        $symbol_query = $_body;

        return $this->searchPortfolioSymbolsAsyncWithHttpInfo($portfolio_group_id, $symbol_query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPortfolioSymbolsAsyncWithHttpInfo
     *
     * Search for symbols limited to brokerages under the specified portfolio group
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to search under (required)
     * @param  \SnapTrade\Model\SymbolQuery $symbol_query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPortfolioSymbols'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPortfolioSymbolsAsyncWithHttpInfo($portfolio_group_id, $symbol_query = null, string $contentType = self::contentTypes['searchPortfolioSymbols'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\UniversalSymbol[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->searchPortfolioSymbolsRequest($portfolio_group_id, $symbol_query, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPortfolioSymbols'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup to search under (required)
     * @param  \SnapTrade\Model\SymbolQuery $symbol_query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPortfolioSymbols'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchPortfolioSymbolsRequest($portfolio_group_id, $symbol_query = SENTINEL_VALUE, string $contentType = self::contentTypes['searchPortfolioSymbols'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling searchPortfolioSymbols'
            );
        }
        if ($symbol_query !== SENTINEL_VALUE) {
            if (!($symbol_query instanceof \SnapTrade\Model\SymbolQuery)) {
                if (!is_array($symbol_query))
                    throw new \InvalidArgumentException('"symbol_query" must be associative array or an instance of \SnapTrade\Model\SymbolQuery PortfolioManagementApi.searchPortfolioSymbols.');
                else
                    $symbol_query = new \SnapTrade\Model\SymbolQuery($symbol_query);
            }
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/symbols';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($symbol_query)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($symbol_query));
            } else {
                $httpBody = $symbol_query;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation setPortfolioTargets
     *
     * Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  \SnapTrade\Model\TargetAsset[] $target_asset target_asset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TargetAsset[]
     */
    public function setPortfolioTargets(
        $portfolio_group_id,

        $body = SENTINEL_VALUE,

        string $contentType = self::contentTypes['setPortfolioTargets'][0]

    )
    {
        $_body = null;
        $target_asset = $body === SENTINEL_VALUE ? null : (empty($_body) ? $body : $_body);

        list($response) = $this->setPortfolioTargetsWithHttpInfo($portfolio_group_id, $target_asset, $contentType);
        return $response;
    }

    /**
     * Operation setPortfolioTargetsWithHttpInfo
     *
     * Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  \SnapTrade\Model\TargetAsset[] $target_asset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TargetAsset[], HTTP status code, HTTP response headers (array of strings)
     */
    public function setPortfolioTargetsWithHttpInfo($portfolio_group_id, $target_asset = null, string $contentType = self::contentTypes['setPortfolioTargets'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->setPortfolioTargetsRequest($portfolio_group_id, $target_asset, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->setPortfolioTargetsWithHttpInfo(
                        $portfolio_group_id,
                        $target_asset,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TargetAsset[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TargetAsset[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TargetAsset[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TargetAsset[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TargetAsset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setPortfolioTargetsAsync
     *
     * Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  \SnapTrade\Model\TargetAsset[] $target_asset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPortfolioTargetsAsync(
        $portfolio_group_id,

        $body = SENTINEL_VALUE,

        string $contentType = self::contentTypes['setPortfolioTargets'][0]

    )
    {
        $_body = null;
        $target_asset = $body === SENTINEL_VALUE ? null : (empty($_body) ? $body : $_body);

        return $this->setPortfolioTargetsAsyncWithHttpInfo($portfolio_group_id, $target_asset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPortfolioTargetsAsyncWithHttpInfo
     *
     * Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  \SnapTrade\Model\TargetAsset[] $target_asset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPortfolioTargetsAsyncWithHttpInfo($portfolio_group_id, $target_asset = null, string $contentType = self::contentTypes['setPortfolioTargets'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TargetAsset[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->setPortfolioTargetsRequest($portfolio_group_id, $target_asset, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPortfolioTargets'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to create the target asset. (required)
     * @param  \SnapTrade\Model\TargetAsset[] $target_asset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPortfolioTargets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setPortfolioTargetsRequest($portfolio_group_id, $target_asset = SENTINEL_VALUE, string $contentType = self::contentTypes['setPortfolioTargets'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling setPortfolioTargets'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/targets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($target_asset)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($target_asset));
            } else {
                $httpBody = $target_asset;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation updateAssetClass
     *
     * Updates model asset class objects
     *
     * @param  string $model_asset_class_id The ID of the model asset class to update. (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ModelAssetClassDetails $model_asset_class_details Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAssetClass(

        $model_asset_class_id,
        $user_id,
        $user_secret,
        $model_asset_class = SENTINEL_VALUE,
        $model_asset_class_target = SENTINEL_VALUE,

        string $contentType = self::contentTypes['updateAssetClass'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "model_asset_class", $model_asset_class);
        $this->setRequestBodyProperty($_body, "model_asset_class_target", $model_asset_class_target);
        $model_asset_class_details = $_body;

        $this->updateAssetClassWithHttpInfo($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, $contentType);
    }

    /**
     * Operation updateAssetClassWithHttpInfo
     *
     * Updates model asset class objects
     *
     * @param  string $model_asset_class_id The ID of the model asset class to update. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ModelAssetClassDetails $model_asset_class_details Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAssetClass'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAssetClassWithHttpInfo($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, string $contentType = self::contentTypes['updateAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->updateAssetClassRequest($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->updateAssetClassWithHttpInfo(
                        $model_asset_class_id,
                        $user_id,
                        $user_secret,
                        $model_asset_class_details,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAssetClassAsync
     *
     * Updates model asset class objects
     *
     * @param  string $model_asset_class_id The ID of the model asset class to update. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ModelAssetClassDetails $model_asset_class_details Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAssetClassAsync(

        $model_asset_class_id,
        $user_id,
        $user_secret,
        $model_asset_class = SENTINEL_VALUE,
        $model_asset_class_target = SENTINEL_VALUE,

        string $contentType = self::contentTypes['updateAssetClass'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "model_asset_class", $model_asset_class);
        $this->setRequestBodyProperty($_body, "model_asset_class_target", $model_asset_class_target);
        $model_asset_class_details = $_body;

        return $this->updateAssetClassAsyncWithHttpInfo($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAssetClassAsyncWithHttpInfo
     *
     * Updates model asset class objects
     *
     * @param  string $model_asset_class_id The ID of the model asset class to update. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ModelAssetClassDetails $model_asset_class_details Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAssetClassAsyncWithHttpInfo($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, string $contentType = self::contentTypes['updateAssetClass'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->updateAssetClassRequest($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAssetClass'
     *
     * @param  string $model_asset_class_id The ID of the model asset class to update. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ModelAssetClassDetails $model_asset_class_details Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAssetClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAssetClassRequest($model_asset_class_id, $user_id, $user_secret, $model_asset_class_details, string $contentType = self::contentTypes['updateAssetClass'][0])
    {

        // Check if $model_asset_class_id is a string
        if ($model_asset_class_id !== SENTINEL_VALUE && !is_string($model_asset_class_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($model_asset_class_id, true), gettype($model_asset_class_id)));
        }
        // verify the required parameter 'model_asset_class_id' is set
        if ($model_asset_class_id === SENTINEL_VALUE || (is_array($model_asset_class_id) && count($model_asset_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_asset_class_id when calling updateAssetClass'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling updateAssetClass'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling updateAssetClass'
            );
        }
        if ($model_asset_class_details !== SENTINEL_VALUE) {
            if (!($model_asset_class_details instanceof \SnapTrade\Model\ModelAssetClassDetails)) {
                if (!is_array($model_asset_class_details))
                    throw new \InvalidArgumentException('"model_asset_class_details" must be associative array or an instance of \SnapTrade\Model\ModelAssetClassDetails PortfolioManagementApi.updateAssetClass.');
                else
                    $model_asset_class_details = new \SnapTrade\Model\ModelAssetClassDetails($model_asset_class_details);
            }
        }
        // verify the required parameter 'model_asset_class_details' is set
        if ($model_asset_class_details === SENTINEL_VALUE || (is_array($model_asset_class_details) && count($model_asset_class_details) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter model_asset_class_details when calling updateAssetClass'
            );
        }


        $resourcePath = '/modelAssetClass/{modelAssetClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($model_asset_class_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'modelAssetClassId' . '}',
                ObjectSerializer::toPathValue($model_asset_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($model_asset_class_details)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($model_asset_class_details));
            } else {
                $httpBody = $model_asset_class_details;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation updatePortfolioSettings
     *
     * Updates portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioSettings'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\PortfolioGroupSettings
     */
    public function updatePortfolioSettings(
        $portfolio_group_id,


        string $contentType = self::contentTypes['updatePortfolioSettings'][0]

    )
    {

        list($response) = $this->updatePortfolioSettingsWithHttpInfo($portfolio_group_id, $contentType);
        return $response;
    }

    /**
     * Operation updatePortfolioSettingsWithHttpInfo
     *
     * Updates portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioSettings'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\PortfolioGroupSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePortfolioSettingsWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['updatePortfolioSettings'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->updatePortfolioSettingsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->updatePortfolioSettingsWithHttpInfo(
                        $portfolio_group_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\PortfolioGroupSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\PortfolioGroupSettings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\PortfolioGroupSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\PortfolioGroupSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\PortfolioGroupSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePortfolioSettingsAsync
     *
     * Updates portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePortfolioSettingsAsync(
        $portfolio_group_id,


        string $contentType = self::contentTypes['updatePortfolioSettings'][0]

    )
    {

        return $this->updatePortfolioSettingsAsyncWithHttpInfo($portfolio_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePortfolioSettingsAsyncWithHttpInfo
     *
     * Updates portfolio group settings
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePortfolioSettingsAsyncWithHttpInfo($portfolio_group_id, string $contentType = self::contentTypes['updatePortfolioSettings'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\PortfolioGroupSettings';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->updatePortfolioSettingsRequest($portfolio_group_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePortfolioSettings'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the settings. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePortfolioSettingsRequest($portfolio_group_id, string $contentType = self::contentTypes['updatePortfolioSettings'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling updatePortfolioSettings'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'PATCH';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation updatePortfolioTargetById
     *
     * Update a TargetAsset under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to patch. (required)
     * @param  \SnapTrade\Model\TargetAsset $target_asset target_asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TargetAsset
     */
    public function updatePortfolioTargetById(

        $portfolio_group_id,
        $target_asset_id,
        $id = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $percent = SENTINEL_VALUE,
        $is_supported = SENTINEL_VALUE,
        $is_excluded = SENTINEL_VALUE,

        string $contentType = self::contentTypes['updatePortfolioTargetById'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "percent", $percent);
        $this->setRequestBodyProperty($_body, "is_supported", $is_supported);
        $this->setRequestBodyProperty($_body, "is_excluded", $is_excluded);
        $target_asset = $_body;

        list($response) = $this->updatePortfolioTargetByIdWithHttpInfo($portfolio_group_id, $target_asset_id, $target_asset, $contentType);
        return $response;
    }

    /**
     * Operation updatePortfolioTargetByIdWithHttpInfo
     *
     * Update a TargetAsset under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to patch. (required)
     * @param  \SnapTrade\Model\TargetAsset $target_asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TargetAsset, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePortfolioTargetByIdWithHttpInfo($portfolio_group_id, $target_asset_id, $target_asset, string $contentType = self::contentTypes['updatePortfolioTargetById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->updatePortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $target_asset, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->updatePortfolioTargetByIdWithHttpInfo(
                        $portfolio_group_id,
                        $target_asset_id,
                        $target_asset,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TargetAsset' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TargetAsset' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TargetAsset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TargetAsset';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TargetAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePortfolioTargetByIdAsync
     *
     * Update a TargetAsset under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to patch. (required)
     * @param  \SnapTrade\Model\TargetAsset $target_asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePortfolioTargetByIdAsync(

        $portfolio_group_id,
        $target_asset_id,
        $id = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $percent = SENTINEL_VALUE,
        $is_supported = SENTINEL_VALUE,
        $is_excluded = SENTINEL_VALUE,

        string $contentType = self::contentTypes['updatePortfolioTargetById'][0]

    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "id", $id);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "percent", $percent);
        $this->setRequestBodyProperty($_body, "is_supported", $is_supported);
        $this->setRequestBodyProperty($_body, "is_excluded", $is_excluded);
        $target_asset = $_body;

        return $this->updatePortfolioTargetByIdAsyncWithHttpInfo($portfolio_group_id, $target_asset_id, $target_asset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePortfolioTargetByIdAsyncWithHttpInfo
     *
     * Update a TargetAsset under the specified PortfolioGroup.
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to patch. (required)
     * @param  \SnapTrade\Model\TargetAsset $target_asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePortfolioTargetByIdAsyncWithHttpInfo($portfolio_group_id, $target_asset_id, $target_asset, string $contentType = self::contentTypes['updatePortfolioTargetById'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TargetAsset';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->updatePortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $target_asset, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePortfolioTargetById'
     *
     * @param  string $portfolio_group_id The ID of the PortfolioGroup under which to patch the target asset. (required)
     * @param  string $target_asset_id The ID of the TargetAsset to patch. (required)
     * @param  \SnapTrade\Model\TargetAsset $target_asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePortfolioTargetById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePortfolioTargetByIdRequest($portfolio_group_id, $target_asset_id, $target_asset, string $contentType = self::contentTypes['updatePortfolioTargetById'][0])
    {

        // Check if $portfolio_group_id is a string
        if ($portfolio_group_id !== SENTINEL_VALUE && !is_string($portfolio_group_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($portfolio_group_id, true), gettype($portfolio_group_id)));
        }
        // verify the required parameter 'portfolio_group_id' is set
        if ($portfolio_group_id === SENTINEL_VALUE || (is_array($portfolio_group_id) && count($portfolio_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter portfolio_group_id when calling updatePortfolioTargetById'
            );
        }
        // Check if $target_asset_id is a string
        if ($target_asset_id !== SENTINEL_VALUE && !is_string($target_asset_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($target_asset_id, true), gettype($target_asset_id)));
        }
        // verify the required parameter 'target_asset_id' is set
        if ($target_asset_id === SENTINEL_VALUE || (is_array($target_asset_id) && count($target_asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter target_asset_id when calling updatePortfolioTargetById'
            );
        }
        if ($target_asset !== SENTINEL_VALUE) {
            if (!($target_asset instanceof \SnapTrade\Model\TargetAsset)) {
                if (!is_array($target_asset))
                    throw new \InvalidArgumentException('"target_asset" must be associative array or an instance of \SnapTrade\Model\TargetAsset PortfolioManagementApi.updatePortfolioTargetById.');
                else
                    $target_asset = new \SnapTrade\Model\TargetAsset($target_asset);
            }
        }
        // verify the required parameter 'target_asset' is set
        if ($target_asset === SENTINEL_VALUE || (is_array($target_asset) && count($target_asset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter target_asset when calling updatePortfolioTargetById'
            );
        }


        $resourcePath = '/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($portfolio_group_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'portfolioGroupId' . '}',
                ObjectSerializer::toPathValue($portfolio_group_id),
                $resourcePath
            );
        }
        // path params
        if ($target_asset_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'targetAssetId' . '}',
                ObjectSerializer::toPathValue($target_asset_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($target_asset)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($target_asset));
            } else {
                $httpBody = $target_asset;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'PATCH';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
