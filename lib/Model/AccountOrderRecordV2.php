<?php
/**
 * AccountOrderRecordV2
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SnapTrade
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * SnapTrade
 *
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 * Generated by: https://konfigthis.com
 */


namespace SnapTrade\Model;

use \ArrayAccess;
use \SnapTrade\ObjectSerializer;

/**
 * AccountOrderRecordV2 Class Doc Comment
 *
 * @category Class
 * @description Describes a single order in the standardized V2 format.
 * @package  SnapTrade
 * @implements \ArrayAccess<string, mixed>
 */
class AccountOrderRecordV2 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'AccountOrderRecordV2';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'brokerage_order_id' => 'string',
        'status' => '\SnapTrade\Model\AccountOrderRecordStatus',
        'order_type' => 'string',
        'time_in_force' => 'string',
        'time_placed' => '\DateTime',
        'time_executed' => '\DateTime',
        'quote_currency' => 'string',
        'execution_price' => 'float',
        'limit_price' => 'float',
        'stop_price' => 'float',
        'legs' => '\SnapTrade\Model\AccountOrderRecordLeg[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'brokerage_order_id' => null,
        'status' => null,
        'order_type' => null,
        'time_in_force' => null,
        'time_placed' => 'date-time',
        'time_executed' => 'date-time',
        'quote_currency' => null,
        'execution_price' => null,
        'limit_price' => null,
        'stop_price' => null,
        'legs' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'brokerage_order_id' => false,
		'status' => false,
		'order_type' => true,
		'time_in_force' => false,
		'time_placed' => false,
		'time_executed' => true,
		'quote_currency' => false,
		'execution_price' => true,
		'limit_price' => true,
		'stop_price' => true,
		'legs' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'brokerage_order_id' => 'brokerage_order_id',
        'status' => 'status',
        'order_type' => 'order_type',
        'time_in_force' => 'time_in_force',
        'time_placed' => 'time_placed',
        'time_executed' => 'time_executed',
        'quote_currency' => 'quote_currency',
        'execution_price' => 'execution_price',
        'limit_price' => 'limit_price',
        'stop_price' => 'stop_price',
        'legs' => 'legs'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'brokerage_order_id' => 'setBrokerageOrderId',
        'status' => 'setStatus',
        'order_type' => 'setOrderType',
        'time_in_force' => 'setTimeInForce',
        'time_placed' => 'setTimePlaced',
        'time_executed' => 'setTimeExecuted',
        'quote_currency' => 'setQuoteCurrency',
        'execution_price' => 'setExecutionPrice',
        'limit_price' => 'setLimitPrice',
        'stop_price' => 'setStopPrice',
        'legs' => 'setLegs'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'brokerage_order_id' => 'getBrokerageOrderId',
        'status' => 'getStatus',
        'order_type' => 'getOrderType',
        'time_in_force' => 'getTimeInForce',
        'time_placed' => 'getTimePlaced',
        'time_executed' => 'getTimeExecuted',
        'quote_currency' => 'getQuoteCurrency',
        'execution_price' => 'getExecutionPrice',
        'limit_price' => 'getLimitPrice',
        'stop_price' => 'getStopPrice',
        'legs' => 'getLegs'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('brokerage_order_id', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('order_type', $data ?? [], null);
        $this->setIfExists('time_in_force', $data ?? [], null);
        $this->setIfExists('time_placed', $data ?? [], null);
        $this->setIfExists('time_executed', $data ?? [], null);
        $this->setIfExists('quote_currency', $data ?? [], null);
        $this->setIfExists('execution_price', $data ?? [], null);
        $this->setIfExists('limit_price', $data ?? [], null);
        $this->setIfExists('stop_price', $data ?? [], null);
        $this->setIfExists('legs', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets brokerage_order_id
     *
     * @return string|null
     */
    public function getBrokerageOrderId()
    {
        return $this->container['brokerage_order_id'];
    }

    /**
     * Sets brokerage_order_id
     *
     * @param string|null $brokerage_order_id Order ID returned by brokerage. This is the unique identifier for the order in the brokerage system.
     *
     * @return self
     */
    public function setBrokerageOrderId($brokerage_order_id)
    {

        if (is_null($brokerage_order_id)) {
            throw new \InvalidArgumentException('non-nullable brokerage_order_id cannot be null');
        }

        $this->container['brokerage_order_id'] = $brokerage_order_id;

        return $this;
    }

    /**
     * Gets status
     *
     * @return \SnapTrade\Model\AccountOrderRecordStatus|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param \SnapTrade\Model\AccountOrderRecordStatus|null $status status
     *
     * @return self
     */
    public function setStatus($status)
    {

        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }

        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets order_type
     *
     * @return string|null
     */
    public function getOrderType()
    {
        return $this->container['order_type'];
    }

    /**
     * Sets order_type
     *
     * @param string|null $order_type The type of order placed.   - `MARKET`   - `LIMIT`   - `STOP`   - `STOP_LIMIT`
     *
     * @return self
     */
    public function setOrderType($order_type)
    {

        if (is_null($order_type)) {
            array_push($this->openAPINullablesSetToNull, 'order_type');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('order_type', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['order_type'] = $order_type;

        return $this;
    }

    /**
     * Gets time_in_force
     *
     * @return string|null
     */
    public function getTimeInForce()
    {
        return $this->container['time_in_force'];
    }

    /**
     * Sets time_in_force
     *
     * @param string|null $time_in_force The Time in Force type for the order. This field indicates how long the order will remain active before it is executed or expires. We try our best to map brokerage time in force values to the following. When mapping fails, we will return the brokerage's time in force value.   - `DAY` - Day. The order is valid only for the trading day on which it is placed.   - `GTC` - Good Til Canceled. The order is valid until it is executed or canceled.   - `FOK` - Fill Or Kill. The order must be executed in its entirety immediately or be canceled completely.   - `IOC` - Immediate Or Cancel. The order must be executed immediately. Any portion of the order that cannot be filled immediately will be canceled.   - `GTD` - Good Til Date. The order is valid until the specified date.   - `MOO` - Market On Open. The order is to be executed at the day's opening price.   - `EHP` - Extended Hours P.M. The order is to be placed during extended hour trading, after markets close.
     *
     * @return self
     */
    public function setTimeInForce($time_in_force)
    {

        if (is_null($time_in_force)) {
            throw new \InvalidArgumentException('non-nullable time_in_force cannot be null');
        }

        $this->container['time_in_force'] = $time_in_force;

        return $this;
    }

    /**
     * Gets time_placed
     *
     * @return \DateTime|null
     */
    public function getTimePlaced()
    {
        return $this->container['time_placed'];
    }

    /**
     * Sets time_placed
     *
     * @param \DateTime|null $time_placed The time the order was placed. This is the time the order was submitted to the brokerage.
     *
     * @return self
     */
    public function setTimePlaced($time_placed)
    {

        if (is_null($time_placed)) {
            throw new \InvalidArgumentException('non-nullable time_placed cannot be null');
        }

        $this->container['time_placed'] = $time_placed;

        return $this;
    }

    /**
     * Gets time_executed
     *
     * @return \DateTime|null
     */
    public function getTimeExecuted()
    {
        return $this->container['time_executed'];
    }

    /**
     * Sets time_executed
     *
     * @param \DateTime|null $time_executed The time the order was executed in the brokerage system. This value is not always available from the brokerage.
     *
     * @return self
     */
    public function setTimeExecuted($time_executed)
    {

        if (is_null($time_executed)) {
            array_push($this->openAPINullablesSetToNull, 'time_executed');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('time_executed', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['time_executed'] = $time_executed;

        return $this;
    }

    /**
     * Gets quote_currency
     *
     * @return string|null
     */
    public function getQuoteCurrency()
    {
        return $this->container['quote_currency'];
    }

    /**
     * Sets quote_currency
     *
     * @param string|null $quote_currency Quote currency code for the order.
     *
     * @return self
     */
    public function setQuoteCurrency($quote_currency)
    {

        if (is_null($quote_currency)) {
            throw new \InvalidArgumentException('non-nullable quote_currency cannot be null');
        }

        $this->container['quote_currency'] = $quote_currency;

        return $this;
    }

    /**
     * Gets execution_price
     *
     * @return float|null
     */
    public function getExecutionPrice()
    {
        return $this->container['execution_price'];
    }

    /**
     * Sets execution_price
     *
     * @param float|null $execution_price The price at which the order was executed.
     *
     * @return self
     */
    public function setExecutionPrice($execution_price)
    {

        if (is_null($execution_price)) {
            array_push($this->openAPINullablesSetToNull, 'execution_price');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('execution_price', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['execution_price'] = $execution_price;

        return $this;
    }

    /**
     * Gets limit_price
     *
     * @return float|null
     */
    public function getLimitPrice()
    {
        return $this->container['limit_price'];
    }

    /**
     * Sets limit_price
     *
     * @param float|null $limit_price The limit price is maximum price one is willing to pay for a buy order or the minimum price one is willing to accept for a sell order. Should only apply to `Limit` and `StopLimit` orders.
     *
     * @return self
     */
    public function setLimitPrice($limit_price)
    {

        if (is_null($limit_price)) {
            array_push($this->openAPINullablesSetToNull, 'limit_price');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('limit_price', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['limit_price'] = $limit_price;

        return $this;
    }

    /**
     * Gets stop_price
     *
     * @return float|null
     */
    public function getStopPrice()
    {
        return $this->container['stop_price'];
    }

    /**
     * Sets stop_price
     *
     * @param float|null $stop_price The stop price is the price at which a stop order is triggered. Should only apply to `Stop` and `StopLimit` orders.
     *
     * @return self
     */
    public function setStopPrice($stop_price)
    {

        if (is_null($stop_price)) {
            array_push($this->openAPINullablesSetToNull, 'stop_price');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('stop_price', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['stop_price'] = $stop_price;

        return $this;
    }

    /**
     * Gets legs
     *
     * @return \SnapTrade\Model\AccountOrderRecordLeg[]|null
     */
    public function getLegs()
    {
        return $this->container['legs'];
    }

    /**
     * Sets legs
     *
     * @param \SnapTrade\Model\AccountOrderRecordLeg[]|null $legs List of legs that make up the order.
     *
     * @return self
     */
    public function setLegs($legs)
    {

        if (is_null($legs)) {
            throw new \InvalidArgumentException('non-nullable legs cannot be null');
        }

        $this->container['legs'] = $legs;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


