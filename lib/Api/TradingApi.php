<?php
/**
 * TradingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  SnapTrade
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * SnapTrade
 *
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 * Generated by: https://konfigthis.com
 */


namespace SnapTrade\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use SnapTrade\ApiException;
use SnapTrade\Configuration;
use SnapTrade\HeaderSelector;
use SnapTrade\ObjectSerializer;

class TradingApi extends \SnapTrade\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cancelOrder' => [
            'application/json',
        ],
        'cancelUserAccountOrder' => [
            'application/json',
        ],
        'getCryptocurrencyPairQuote' => [
            'application/json',
        ],
        'getOrderImpact' => [
            'application/json',
        ],
        'getUserAccountQuotes' => [
            'application/json',
        ],
        'placeBracketOrder' => [
            'application/json',
        ],
        'placeForceOrder' => [
            'application/json',
        ],
        'placeMlegOrder' => [
            'application/json',
        ],
        'placeOrder' => [
            'application/json',
        ],
        'placeSimpleOrder' => [
            'application/json',
        ],
        'previewSimpleOrder' => [
            'application/json',
        ],
        'replaceOrder' => [
            'application/json',
        ],
        'searchCryptocurrencyPairInstruments' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation cancelOrder
     *
     * Cancel crypto order
     *
     * Cancels an order in the specified account.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  string $brokerage_order_id brokerage_order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\OrderUpdatedResponse|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function cancelOrder(
        $user_id,
        $user_secret,
        $account_id,
        $brokerage_order_id,

        string $contentType = self::contentTypes['cancelOrder'][0]
    )
    {

        list($response) = $this->cancelOrderWithHttpInfo($user_id, $user_secret, $account_id, $brokerage_order_id, $contentType);
        return $response;
    }

    /**
     * Operation cancelOrderWithHttpInfo
     *
     * Cancel crypto order
     *
     * Cancels an order in the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $brokerage_order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\OrderUpdatedResponse|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelOrderWithHttpInfo($user_id, $user_secret, $account_id, $brokerage_order_id, string $contentType = self::contentTypes['cancelOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->cancelOrderRequest($user_id, $user_secret, $account_id, $brokerage_order_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->cancelOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $brokerage_order_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\OrderUpdatedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\OrderUpdatedResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\OrderUpdatedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\OrderUpdatedResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\OrderUpdatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelOrderAsync
     *
     * Cancel crypto order
     *
     * Cancels an order in the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $brokerage_order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOrderAsync(
        $user_id,
        $user_secret,
        $account_id,
        $brokerage_order_id,

        string $contentType = self::contentTypes['cancelOrder'][0]
    )
    {

        return $this->cancelOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $brokerage_order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelOrderAsyncWithHttpInfo
     *
     * Cancel crypto order
     *
     * Cancels an order in the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $brokerage_order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $brokerage_order_id, string $contentType = self::contentTypes['cancelOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\OrderUpdatedResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->cancelOrderRequest($user_id, $user_secret, $account_id, $brokerage_order_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $brokerage_order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelOrderRequest($user_id, $user_secret, $account_id, $brokerage_order_id, string $contentType = self::contentTypes['cancelOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling cancelOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling cancelOrder'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling cancelOrder'
            );
        }
        // Check if $brokerage_order_id is a string
        if ($brokerage_order_id !== SENTINEL_VALUE && !is_string($brokerage_order_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($brokerage_order_id, true), gettype($brokerage_order_id)));
        }
        // verify the required parameter 'brokerage_order_id' is set
        if ($brokerage_order_id === SENTINEL_VALUE || (is_array($brokerage_order_id) && count($brokerage_order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter brokerage_order_id when calling cancelOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/simple/{brokerageOrderId}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brokerage_order_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'brokerageOrderId' . '}',
                ObjectSerializer::toPathValue($brokerage_order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation cancelUserAccountOrder
     *
     * Cancel equity order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model500UnexpectedExceptionResponse
     */
    public function cancelUserAccountOrder(

        $user_id,
        $user_secret,
        $account_id,
        $brokerage_order_id = SENTINEL_VALUE,
        string $contentType = self::contentTypes['cancelUserAccountOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "brokerage_order_id", $brokerage_order_id);
        $trading_cancel_user_account_order_request = $_body;

        list($response) = $this->cancelUserAccountOrderWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType);
        return $response;
    }

    /**
     * Operation cancelUserAccountOrderWithHttpInfo
     *
     * Cancel equity order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model500UnexpectedExceptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelUserAccountOrderWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, string $contentType = self::contentTypes['cancelUserAccountOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->cancelUserAccountOrderRequest($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->cancelUserAccountOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $trading_cancel_user_account_order_request,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model500UnexpectedExceptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model500UnexpectedExceptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelUserAccountOrderAsync
     *
     * Cancel equity order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelUserAccountOrderAsync(

        $user_id,
        $user_secret,
        $account_id,
        $brokerage_order_id = SENTINEL_VALUE,
        string $contentType = self::contentTypes['cancelUserAccountOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "brokerage_order_id", $brokerage_order_id);
        $trading_cancel_user_account_order_request = $_body;

        return $this->cancelUserAccountOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelUserAccountOrderAsyncWithHttpInfo
     *
     * Cancel equity order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelUserAccountOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, string $contentType = self::contentTypes['cancelUserAccountOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->cancelUserAccountOrderRequest($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelUserAccountOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelUserAccountOrderRequest($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, string $contentType = self::contentTypes['cancelUserAccountOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling cancelUserAccountOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling cancelUserAccountOrder'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling cancelUserAccountOrder'
            );
        }
        if ($trading_cancel_user_account_order_request !== SENTINEL_VALUE) {
            if (!($trading_cancel_user_account_order_request instanceof \SnapTrade\Model\TradingCancelUserAccountOrderRequest)) {
                if (!is_array($trading_cancel_user_account_order_request))
                    throw new \InvalidArgumentException('"trading_cancel_user_account_order_request" must be associative array or an instance of \SnapTrade\Model\TradingCancelUserAccountOrderRequest TradingApi.cancelUserAccountOrder.');
                else
                    $trading_cancel_user_account_order_request = new \SnapTrade\Model\TradingCancelUserAccountOrderRequest($trading_cancel_user_account_order_request);
            }
        }
        // verify the required parameter 'trading_cancel_user_account_order_request' is set
        if ($trading_cancel_user_account_order_request === SENTINEL_VALUE || (is_array($trading_cancel_user_account_order_request) && count($trading_cancel_user_account_order_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter trading_cancel_user_account_order_request when calling cancelUserAccountOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/orders/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($trading_cancel_user_account_order_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($trading_cancel_user_account_order_request));
            } else {
                $httpBody = $trading_cancel_user_account_order_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getCryptocurrencyPairQuote
     *
     * Get crypto pair quote
     *
     * Gets a quote for the specified account.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  string $instrument_symbol instrument_symbol (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptocurrencyPairQuote'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\CryptocurrencyPairQuote|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function getCryptocurrencyPairQuote(
        $user_id,
        $user_secret,
        $account_id,
        $instrument_symbol,

        string $contentType = self::contentTypes['getCryptocurrencyPairQuote'][0]
    )
    {

        list($response) = $this->getCryptocurrencyPairQuoteWithHttpInfo($user_id, $user_secret, $account_id, $instrument_symbol, $contentType);
        return $response;
    }

    /**
     * Operation getCryptocurrencyPairQuoteWithHttpInfo
     *
     * Get crypto pair quote
     *
     * Gets a quote for the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $instrument_symbol (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptocurrencyPairQuote'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\CryptocurrencyPairQuote|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCryptocurrencyPairQuoteWithHttpInfo($user_id, $user_secret, $account_id, $instrument_symbol, string $contentType = self::contentTypes['getCryptocurrencyPairQuote'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getCryptocurrencyPairQuoteRequest($user_id, $user_secret, $account_id, $instrument_symbol, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getCryptocurrencyPairQuoteWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $instrument_symbol,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\CryptocurrencyPairQuote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\CryptocurrencyPairQuote' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\CryptocurrencyPairQuote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\CryptocurrencyPairQuote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\CryptocurrencyPairQuote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCryptocurrencyPairQuoteAsync
     *
     * Get crypto pair quote
     *
     * Gets a quote for the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $instrument_symbol (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptocurrencyPairQuote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptocurrencyPairQuoteAsync(
        $user_id,
        $user_secret,
        $account_id,
        $instrument_symbol,

        string $contentType = self::contentTypes['getCryptocurrencyPairQuote'][0]
    )
    {

        return $this->getCryptocurrencyPairQuoteAsyncWithHttpInfo($user_id, $user_secret, $account_id, $instrument_symbol, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCryptocurrencyPairQuoteAsyncWithHttpInfo
     *
     * Get crypto pair quote
     *
     * Gets a quote for the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $instrument_symbol (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptocurrencyPairQuote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptocurrencyPairQuoteAsyncWithHttpInfo($user_id, $user_secret, $account_id, $instrument_symbol, string $contentType = self::contentTypes['getCryptocurrencyPairQuote'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\CryptocurrencyPairQuote';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getCryptocurrencyPairQuoteRequest($user_id, $user_secret, $account_id, $instrument_symbol, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCryptocurrencyPairQuote'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $instrument_symbol (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptocurrencyPairQuote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCryptocurrencyPairQuoteRequest($user_id, $user_secret, $account_id, $instrument_symbol, string $contentType = self::contentTypes['getCryptocurrencyPairQuote'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getCryptocurrencyPairQuote'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getCryptocurrencyPairQuote'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling getCryptocurrencyPairQuote'
            );
        }
        // Check if $instrument_symbol is a string
        if ($instrument_symbol !== SENTINEL_VALUE && !is_string($instrument_symbol)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($instrument_symbol, true), gettype($instrument_symbol)));
        }
        // verify the required parameter 'instrument_symbol' is set
        if ($instrument_symbol === SENTINEL_VALUE || (is_array($instrument_symbol) && count($instrument_symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter instrument_symbol when calling getCryptocurrencyPairQuote'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/instruments/cryptocurrencyPairs/{instrumentSymbol}/quote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($instrument_symbol !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'instrumentSymbol' . '}',
                ObjectSerializer::toPathValue($instrument_symbol),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getOrderImpact
     *
     * Check equity order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ManualTradeAndImpact|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse
     */
    public function getOrderImpact(

        $account_id,
        $action,
        $universal_symbol_id,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['getOrderImpact'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form = $_body;

        list($response) = $this->getOrderImpactWithHttpInfo($user_id, $user_secret, $manual_trade_form, $contentType);
        return $response;
    }

    /**
     * Operation getOrderImpactWithHttpInfo
     *
     * Check equity order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ManualTradeAndImpact|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderImpactWithHttpInfo($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['getOrderImpact'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getOrderImpactRequest($user_id, $user_secret, $manual_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getOrderImpactWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $manual_trade_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ManualTradeAndImpact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ManualTradeAndImpact' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ManualTradeAndImpact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\SnapTrade\Model\Model403FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model403FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model403FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ManualTradeAndImpact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ManualTradeAndImpact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model403FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderImpactAsync
     *
     * Check equity order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderImpactAsync(

        $account_id,
        $action,
        $universal_symbol_id,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['getOrderImpact'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form = $_body;

        return $this->getOrderImpactAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderImpactAsyncWithHttpInfo
     *
     * Check equity order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderImpactAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['getOrderImpact'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ManualTradeAndImpact';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getOrderImpactRequest($user_id, $user_secret, $manual_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderImpact'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderImpactRequest($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['getOrderImpact'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getOrderImpact'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getOrderImpact'
            );
        }
        if ($manual_trade_form !== SENTINEL_VALUE) {
            if (!($manual_trade_form instanceof \SnapTrade\Model\ManualTradeForm)) {
                if (!is_array($manual_trade_form))
                    throw new \InvalidArgumentException('"manual_trade_form" must be associative array or an instance of \SnapTrade\Model\ManualTradeForm TradingApi.getOrderImpact.');
                else
                    $manual_trade_form = new \SnapTrade\Model\ManualTradeForm($manual_trade_form);
            }
        }
        // verify the required parameter 'manual_trade_form' is set
        if ($manual_trade_form === SENTINEL_VALUE || (is_array($manual_trade_form) && count($manual_trade_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter manual_trade_form when calling getOrderImpact'
            );
        }


        $resourcePath = '/trade/impact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manual_trade_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($manual_trade_form));
            } else {
                $httpBody = $manual_trade_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getUserAccountQuotes
     *
     * Get equity symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator (required)
     * @param  string $account_id account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\SymbolsQuotesInner[]|\SnapTrade\Model\Model500UnexpectedExceptionResponse
     */
    public function getUserAccountQuotes(
        $user_id,
        $user_secret,
        $symbols,
        $account_id,
        $use_ticker = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getUserAccountQuotes'][0]
    )
    {

        list($response) = $this->getUserAccountQuotesWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType);
        return $response;
    }

    /**
     * Operation getUserAccountQuotesWithHttpInfo
     *
     * Get equity symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\SymbolsQuotesInner[]|\SnapTrade\Model\Model500UnexpectedExceptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserAccountQuotesWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker = null, string $contentType = self::contentTypes['getUserAccountQuotes'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getUserAccountQuotesRequest($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getUserAccountQuotesWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $symbols,
                        $account_id,
                        $use_ticker,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\SymbolsQuotesInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\SymbolsQuotesInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\SymbolsQuotesInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model500UnexpectedExceptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\SymbolsQuotesInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\SymbolsQuotesInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model500UnexpectedExceptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAccountQuotesAsync
     *
     * Get equity symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAccountQuotesAsync(
        $user_id,
        $user_secret,
        $symbols,
        $account_id,
        $use_ticker = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getUserAccountQuotes'][0]
    )
    {

        return $this->getUserAccountQuotesAsyncWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAccountQuotesAsyncWithHttpInfo
     *
     * Get equity symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAccountQuotesAsyncWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker = null, string $contentType = self::contentTypes['getUserAccountQuotes'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\SymbolsQuotesInner[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getUserAccountQuotesRequest($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserAccountQuotes'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserAccountQuotesRequest($user_id, $user_secret, $symbols, $account_id, $use_ticker = SENTINEL_VALUE, string $contentType = self::contentTypes['getUserAccountQuotes'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getUserAccountQuotes'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getUserAccountQuotes'
            );
        }
        // Check if $symbols is a string
        if ($symbols !== SENTINEL_VALUE && !is_string($symbols)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($symbols, true), gettype($symbols)));
        }
        // verify the required parameter 'symbols' is set
        if ($symbols === SENTINEL_VALUE || (is_array($symbols) && count($symbols) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter symbols when calling getUserAccountQuotes'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling getUserAccountQuotes'
            );
        }


        $resourcePath = '/accounts/{accountId}/quotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($symbols !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $symbols,
                'symbols', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($use_ticker !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $use_ticker,
                'use_ticker', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeBracketOrder
     *
     * Place bracket equity order
     *
     * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormBracket $manual_trade_form_bracket manual_trade_form_bracket (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeBracketOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse
     */
    public function placeBracketOrder(

        $action,
        $instrument,
        $order_type,
        $time_in_force,
        $stop_loss,
        $take_profit,
        $account_id,
        $user_id,
        $user_secret,
        $symbol = SENTINEL_VALUE,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeBracketOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "instrument", $instrument);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "stop_loss", $stop_loss);
        $this->setRequestBodyProperty($_body, "take_profit", $take_profit);
        $manual_trade_form_bracket = $_body;

        list($response) = $this->placeBracketOrderWithHttpInfo($account_id, $user_id, $user_secret, $manual_trade_form_bracket, $contentType);
        return $response;
    }

    /**
     * Operation placeBracketOrderWithHttpInfo
     *
     * Place bracket equity order
     *
     * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormBracket $manual_trade_form_bracket (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeBracketOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeBracketOrderWithHttpInfo($account_id, $user_id, $user_secret, $manual_trade_form_bracket, string $contentType = self::contentTypes['placeBracketOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeBracketOrderRequest($account_id, $user_id, $user_secret, $manual_trade_form_bracket, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeBracketOrderWithHttpInfo(
                        $account_id,
                        $user_id,
                        $user_secret,
                        $manual_trade_form_bracket,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\SnapTrade\Model\Model403FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model403FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model403FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model403FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeBracketOrderAsync
     *
     * Place bracket equity order
     *
     * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormBracket $manual_trade_form_bracket (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeBracketOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeBracketOrderAsync(

        $action,
        $instrument,
        $order_type,
        $time_in_force,
        $stop_loss,
        $take_profit,
        $account_id,
        $user_id,
        $user_secret,
        $symbol = SENTINEL_VALUE,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeBracketOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "instrument", $instrument);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "stop_loss", $stop_loss);
        $this->setRequestBodyProperty($_body, "take_profit", $take_profit);
        $manual_trade_form_bracket = $_body;

        return $this->placeBracketOrderAsyncWithHttpInfo($account_id, $user_id, $user_secret, $manual_trade_form_bracket, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeBracketOrderAsyncWithHttpInfo
     *
     * Place bracket equity order
     *
     * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormBracket $manual_trade_form_bracket (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeBracketOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeBracketOrderAsyncWithHttpInfo($account_id, $user_id, $user_secret, $manual_trade_form_bracket, string $contentType = self::contentTypes['placeBracketOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeBracketOrderRequest($account_id, $user_id, $user_secret, $manual_trade_form_bracket, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeBracketOrder'
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormBracket $manual_trade_form_bracket (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeBracketOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeBracketOrderRequest($account_id, $user_id, $user_secret, $manual_trade_form_bracket, string $contentType = self::contentTypes['placeBracketOrder'][0])
    {

        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling placeBracketOrder'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeBracketOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeBracketOrder'
            );
        }
        if ($manual_trade_form_bracket !== SENTINEL_VALUE) {
            if (!($manual_trade_form_bracket instanceof \SnapTrade\Model\ManualTradeFormBracket)) {
                if (!is_array($manual_trade_form_bracket))
                    throw new \InvalidArgumentException('"manual_trade_form_bracket" must be associative array or an instance of \SnapTrade\Model\ManualTradeFormBracket TradingApi.placeBracketOrder.');
                else
                    $manual_trade_form_bracket = new \SnapTrade\Model\ManualTradeFormBracket($manual_trade_form_bracket);
            }
        }
        // verify the required parameter 'manual_trade_form_bracket' is set
        if ($manual_trade_form_bracket === SENTINEL_VALUE || (is_array($manual_trade_form_bracket) && count($manual_trade_form_bracket) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter manual_trade_form_bracket when calling placeBracketOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/bracket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manual_trade_form_bracket)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($manual_trade_form_bracket));
            } else {
                $httpBody = $manual_trade_form_bracket;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeForceOrder
     *
     * Place equity order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormWithOptions $manual_trade_form_with_options manual_trade_form_with_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse
     */
    public function placeForceOrder(

        $account_id,
        $action,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $universal_symbol_id = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeForceOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form_with_options = $_body;

        list($response) = $this->placeForceOrderWithHttpInfo($user_id, $user_secret, $manual_trade_form_with_options, $contentType);
        return $response;
    }

    /**
     * Operation placeForceOrderWithHttpInfo
     *
     * Place equity order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormWithOptions $manual_trade_form_with_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeForceOrderWithHttpInfo($user_id, $user_secret, $manual_trade_form_with_options, string $contentType = self::contentTypes['placeForceOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeForceOrderRequest($user_id, $user_secret, $manual_trade_form_with_options, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeForceOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $manual_trade_form_with_options,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\SnapTrade\Model\Model403FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model403FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model403FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model403FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeForceOrderAsync
     *
     * Place equity order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormWithOptions $manual_trade_form_with_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeForceOrderAsync(

        $account_id,
        $action,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $universal_symbol_id = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeForceOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form_with_options = $_body;

        return $this->placeForceOrderAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form_with_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeForceOrderAsyncWithHttpInfo
     *
     * Place equity order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormWithOptions $manual_trade_form_with_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeForceOrderAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form_with_options, string $contentType = self::contentTypes['placeForceOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeForceOrderRequest($user_id, $user_secret, $manual_trade_form_with_options, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeForceOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeFormWithOptions $manual_trade_form_with_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeForceOrderRequest($user_id, $user_secret, $manual_trade_form_with_options, string $contentType = self::contentTypes['placeForceOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeForceOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeForceOrder'
            );
        }
        if ($manual_trade_form_with_options !== SENTINEL_VALUE) {
            if (!($manual_trade_form_with_options instanceof \SnapTrade\Model\ManualTradeFormWithOptions)) {
                if (!is_array($manual_trade_form_with_options))
                    throw new \InvalidArgumentException('"manual_trade_form_with_options" must be associative array or an instance of \SnapTrade\Model\ManualTradeFormWithOptions TradingApi.placeForceOrder.');
                else
                    $manual_trade_form_with_options = new \SnapTrade\Model\ManualTradeFormWithOptions($manual_trade_form_with_options);
            }
        }
        // verify the required parameter 'manual_trade_form_with_options' is set
        if ($manual_trade_form_with_options === SENTINEL_VALUE || (is_array($manual_trade_form_with_options) && count($manual_trade_form_with_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter manual_trade_form_with_options when calling placeForceOrder'
            );
        }


        $resourcePath = '/trade/place';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manual_trade_form_with_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($manual_trade_form_with_options));
            } else {
                $httpBody = $manual_trade_form_with_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeMlegOrder
     *
     * Place option order
     *
     * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  \SnapTrade\Model\MlegTradeForm $mleg_trade_form mleg_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeMlegOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\MlegOrderResponse|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function placeMlegOrder(

        $order_type,
        $time_in_force,
        $legs,
        $user_id,
        $user_secret,
        $account_id,
        $limit_price = SENTINEL_VALUE,
        $stop_price = SENTINEL_VALUE,
        $price_effect = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeMlegOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "limit_price", $limit_price);
        $this->setRequestBodyProperty($_body, "stop_price", $stop_price);
        $this->setRequestBodyProperty($_body, "price_effect", $price_effect);
        $this->setRequestBodyProperty($_body, "legs", $legs);
        $mleg_trade_form = $_body;

        list($response) = $this->placeMlegOrderWithHttpInfo($user_id, $user_secret, $account_id, $mleg_trade_form, $contentType);
        return $response;
    }

    /**
     * Operation placeMlegOrderWithHttpInfo
     *
     * Place option order
     *
     * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\MlegTradeForm $mleg_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeMlegOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\MlegOrderResponse|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeMlegOrderWithHttpInfo($user_id, $user_secret, $account_id, $mleg_trade_form, string $contentType = self::contentTypes['placeMlegOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeMlegOrderRequest($user_id, $user_secret, $account_id, $mleg_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeMlegOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $mleg_trade_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\MlegOrderResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\MlegOrderResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\MlegOrderResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\MlegOrderResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\MlegOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeMlegOrderAsync
     *
     * Place option order
     *
     * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\MlegTradeForm $mleg_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeMlegOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeMlegOrderAsync(

        $order_type,
        $time_in_force,
        $legs,
        $user_id,
        $user_secret,
        $account_id,
        $limit_price = SENTINEL_VALUE,
        $stop_price = SENTINEL_VALUE,
        $price_effect = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeMlegOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "limit_price", $limit_price);
        $this->setRequestBodyProperty($_body, "stop_price", $stop_price);
        $this->setRequestBodyProperty($_body, "price_effect", $price_effect);
        $this->setRequestBodyProperty($_body, "legs", $legs);
        $mleg_trade_form = $_body;

        return $this->placeMlegOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $mleg_trade_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeMlegOrderAsyncWithHttpInfo
     *
     * Place option order
     *
     * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\MlegTradeForm $mleg_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeMlegOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeMlegOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $mleg_trade_form, string $contentType = self::contentTypes['placeMlegOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\MlegOrderResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeMlegOrderRequest($user_id, $user_secret, $account_id, $mleg_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeMlegOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\MlegTradeForm $mleg_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeMlegOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeMlegOrderRequest($user_id, $user_secret, $account_id, $mleg_trade_form, string $contentType = self::contentTypes['placeMlegOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeMlegOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeMlegOrder'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling placeMlegOrder'
            );
        }
        if ($mleg_trade_form !== SENTINEL_VALUE) {
            if (!($mleg_trade_form instanceof \SnapTrade\Model\MlegTradeForm)) {
                if (!is_array($mleg_trade_form))
                    throw new \InvalidArgumentException('"mleg_trade_form" must be associative array or an instance of \SnapTrade\Model\MlegTradeForm TradingApi.placeMlegOrder.');
                else
                    $mleg_trade_form = new \SnapTrade\Model\MlegTradeForm($mleg_trade_form);
            }
        }
        // verify the required parameter 'mleg_trade_form' is set
        if ($mleg_trade_form === SENTINEL_VALUE || (is_array($mleg_trade_form) && count($mleg_trade_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter mleg_trade_form when calling placeMlegOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mleg_trade_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($mleg_trade_form));
            } else {
                $httpBody = $mleg_trade_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeOrder
     *
     * Place checked equity order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function placeOrder(
        $trade_id,
        $user_id,
        $user_secret,
        $wait_to_confirm = SENTINEL_VALUE,

        string $contentType = self::contentTypes['placeOrder'][0]
    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "wait_to_confirm", $wait_to_confirm);
        $validated_trade_body = $_body;

        list($response) = $this->placeOrderWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType);
        return $response;
    }

    /**
     * Operation placeOrderWithHttpInfo
     *
     * Place checked equity order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeOrderWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body = null, string $contentType = self::contentTypes['placeOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeOrderRequest($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeOrderWithHttpInfo(
                        $trade_id,
                        $user_id,
                        $user_secret,
                        $validated_trade_body,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeOrderAsync
     *
     * Place checked equity order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeOrderAsync(
        $trade_id,
        $user_id,
        $user_secret,
        $wait_to_confirm = SENTINEL_VALUE,

        string $contentType = self::contentTypes['placeOrder'][0]
    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "wait_to_confirm", $wait_to_confirm);
        $validated_trade_body = $_body;

        return $this->placeOrderAsyncWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeOrderAsyncWithHttpInfo
     *
     * Place checked equity order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeOrderAsyncWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body = null, string $contentType = self::contentTypes['placeOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeOrderRequest($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeOrder'
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeOrderRequest($trade_id, $user_id, $user_secret, $validated_trade_body = SENTINEL_VALUE, string $contentType = self::contentTypes['placeOrder'][0])
    {

        // Check if $trade_id is a string
        if ($trade_id !== SENTINEL_VALUE && !is_string($trade_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($trade_id, true), gettype($trade_id)));
        }
        // verify the required parameter 'trade_id' is set
        if ($trade_id === SENTINEL_VALUE || (is_array($trade_id) && count($trade_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter trade_id when calling placeOrder'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeOrder'
            );
        }
        if ($validated_trade_body !== SENTINEL_VALUE) {
            if (!($validated_trade_body instanceof \SnapTrade\Model\ValidatedTradeBody)) {
                if (!is_array($validated_trade_body))
                    throw new \InvalidArgumentException('"validated_trade_body" must be associative array or an instance of \SnapTrade\Model\ValidatedTradeBody TradingApi.placeOrder.');
                else
                    $validated_trade_body = new \SnapTrade\Model\ValidatedTradeBody($validated_trade_body);
            }
        }


        $resourcePath = '/trade/{tradeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($trade_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'tradeId' . '}',
                ObjectSerializer::toPathValue($trade_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validated_trade_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($validated_trade_body));
            } else {
                $httpBody = $validated_trade_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeSimpleOrder
     *
     * Place crypto order
     *
     * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeSimpleOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\OrderUpdatedResponse|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function placeSimpleOrder(

        $instrument,
        $side,
        $type,
        $time_in_force,
        $amount,
        $user_id,
        $user_secret,
        $account_id,
        $limit_price = SENTINEL_VALUE,
        $stop_price = SENTINEL_VALUE,
        $post_only = SENTINEL_VALUE,
        $expiration_date = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeSimpleOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "instrument", $instrument);
        $this->setRequestBodyProperty($_body, "side", $side);
        $this->setRequestBodyProperty($_body, "type", $type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "amount", $amount);
        $this->setRequestBodyProperty($_body, "limit_price", $limit_price);
        $this->setRequestBodyProperty($_body, "stop_price", $stop_price);
        $this->setRequestBodyProperty($_body, "post_only", $post_only);
        $this->setRequestBodyProperty($_body, "expiration_date", $expiration_date);
        $simple_order_form = $_body;

        list($response) = $this->placeSimpleOrderWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, $contentType);
        return $response;
    }

    /**
     * Operation placeSimpleOrderWithHttpInfo
     *
     * Place crypto order
     *
     * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeSimpleOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\OrderUpdatedResponse|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeSimpleOrderWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, string $contentType = self::contentTypes['placeSimpleOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeSimpleOrderRequest($user_id, $user_secret, $account_id, $simple_order_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeSimpleOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $simple_order_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\OrderUpdatedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\OrderUpdatedResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\OrderUpdatedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\OrderUpdatedResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\OrderUpdatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeSimpleOrderAsync
     *
     * Place crypto order
     *
     * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeSimpleOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeSimpleOrderAsync(

        $instrument,
        $side,
        $type,
        $time_in_force,
        $amount,
        $user_id,
        $user_secret,
        $account_id,
        $limit_price = SENTINEL_VALUE,
        $stop_price = SENTINEL_VALUE,
        $post_only = SENTINEL_VALUE,
        $expiration_date = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeSimpleOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "instrument", $instrument);
        $this->setRequestBodyProperty($_body, "side", $side);
        $this->setRequestBodyProperty($_body, "type", $type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "amount", $amount);
        $this->setRequestBodyProperty($_body, "limit_price", $limit_price);
        $this->setRequestBodyProperty($_body, "stop_price", $stop_price);
        $this->setRequestBodyProperty($_body, "post_only", $post_only);
        $this->setRequestBodyProperty($_body, "expiration_date", $expiration_date);
        $simple_order_form = $_body;

        return $this->placeSimpleOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeSimpleOrderAsyncWithHttpInfo
     *
     * Place crypto order
     *
     * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeSimpleOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeSimpleOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, string $contentType = self::contentTypes['placeSimpleOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\OrderUpdatedResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeSimpleOrderRequest($user_id, $user_secret, $account_id, $simple_order_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeSimpleOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeSimpleOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeSimpleOrderRequest($user_id, $user_secret, $account_id, $simple_order_form, string $contentType = self::contentTypes['placeSimpleOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeSimpleOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeSimpleOrder'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling placeSimpleOrder'
            );
        }
        if ($simple_order_form !== SENTINEL_VALUE) {
            if (!($simple_order_form instanceof \SnapTrade\Model\SimpleOrderForm)) {
                if (!is_array($simple_order_form))
                    throw new \InvalidArgumentException('"simple_order_form" must be associative array or an instance of \SnapTrade\Model\SimpleOrderForm TradingApi.placeSimpleOrder.');
                else
                    $simple_order_form = new \SnapTrade\Model\SimpleOrderForm($simple_order_form);
            }
        }
        // verify the required parameter 'simple_order_form' is set
        if ($simple_order_form === SENTINEL_VALUE || (is_array($simple_order_form) && count($simple_order_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter simple_order_form when calling placeSimpleOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/simple';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($simple_order_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($simple_order_form));
            } else {
                $httpBody = $simple_order_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation previewSimpleOrder
     *
     * Preview crypto order
     *
     * Previews an order using the specified account.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewSimpleOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\SimpleOrderPreview|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function previewSimpleOrder(

        $instrument,
        $side,
        $type,
        $time_in_force,
        $amount,
        $user_id,
        $user_secret,
        $account_id,
        $limit_price = SENTINEL_VALUE,
        $stop_price = SENTINEL_VALUE,
        $post_only = SENTINEL_VALUE,
        $expiration_date = SENTINEL_VALUE,
        string $contentType = self::contentTypes['previewSimpleOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "instrument", $instrument);
        $this->setRequestBodyProperty($_body, "side", $side);
        $this->setRequestBodyProperty($_body, "type", $type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "amount", $amount);
        $this->setRequestBodyProperty($_body, "limit_price", $limit_price);
        $this->setRequestBodyProperty($_body, "stop_price", $stop_price);
        $this->setRequestBodyProperty($_body, "post_only", $post_only);
        $this->setRequestBodyProperty($_body, "expiration_date", $expiration_date);
        $simple_order_form = $_body;

        list($response) = $this->previewSimpleOrderWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, $contentType);
        return $response;
    }

    /**
     * Operation previewSimpleOrderWithHttpInfo
     *
     * Preview crypto order
     *
     * Previews an order using the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewSimpleOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\SimpleOrderPreview|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function previewSimpleOrderWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, string $contentType = self::contentTypes['previewSimpleOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->previewSimpleOrderRequest($user_id, $user_secret, $account_id, $simple_order_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->previewSimpleOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $simple_order_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\SimpleOrderPreview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\SimpleOrderPreview' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\SimpleOrderPreview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\SimpleOrderPreview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\SimpleOrderPreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation previewSimpleOrderAsync
     *
     * Preview crypto order
     *
     * Previews an order using the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewSimpleOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previewSimpleOrderAsync(

        $instrument,
        $side,
        $type,
        $time_in_force,
        $amount,
        $user_id,
        $user_secret,
        $account_id,
        $limit_price = SENTINEL_VALUE,
        $stop_price = SENTINEL_VALUE,
        $post_only = SENTINEL_VALUE,
        $expiration_date = SENTINEL_VALUE,
        string $contentType = self::contentTypes['previewSimpleOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "instrument", $instrument);
        $this->setRequestBodyProperty($_body, "side", $side);
        $this->setRequestBodyProperty($_body, "type", $type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "amount", $amount);
        $this->setRequestBodyProperty($_body, "limit_price", $limit_price);
        $this->setRequestBodyProperty($_body, "stop_price", $stop_price);
        $this->setRequestBodyProperty($_body, "post_only", $post_only);
        $this->setRequestBodyProperty($_body, "expiration_date", $expiration_date);
        $simple_order_form = $_body;

        return $this->previewSimpleOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation previewSimpleOrderAsyncWithHttpInfo
     *
     * Preview crypto order
     *
     * Previews an order using the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewSimpleOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previewSimpleOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $simple_order_form, string $contentType = self::contentTypes['previewSimpleOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\SimpleOrderPreview';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->previewSimpleOrderRequest($user_id, $user_secret, $account_id, $simple_order_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'previewSimpleOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\SimpleOrderForm $simple_order_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewSimpleOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function previewSimpleOrderRequest($user_id, $user_secret, $account_id, $simple_order_form, string $contentType = self::contentTypes['previewSimpleOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling previewSimpleOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling previewSimpleOrder'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling previewSimpleOrder'
            );
        }
        if ($simple_order_form !== SENTINEL_VALUE) {
            if (!($simple_order_form instanceof \SnapTrade\Model\SimpleOrderForm)) {
                if (!is_array($simple_order_form))
                    throw new \InvalidArgumentException('"simple_order_form" must be associative array or an instance of \SnapTrade\Model\SimpleOrderForm TradingApi.previewSimpleOrder.');
                else
                    $simple_order_form = new \SnapTrade\Model\SimpleOrderForm($simple_order_form);
            }
        }
        // verify the required parameter 'simple_order_form' is set
        if ($simple_order_form === SENTINEL_VALUE || (is_array($simple_order_form) && count($simple_order_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter simple_order_form when calling previewSimpleOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/simple/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($simple_order_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($simple_order_form));
            } else {
                $httpBody = $simple_order_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation replaceOrder
     *
     * Replace crypto order
     *
     * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order&#39;s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $brokerage_order_id The Brokerage Order ID of the order to replace. (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeReplaceForm $manual_trade_replace_form manual_trade_replace_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse
     */
    public function replaceOrder(

        $action,
        $order_type,
        $time_in_force,
        $account_id,
        $brokerage_order_id,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        string $contentType = self::contentTypes['replaceOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $manual_trade_replace_form = $_body;

        list($response) = $this->replaceOrderWithHttpInfo($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, $contentType);
        return $response;
    }

    /**
     * Operation replaceOrderWithHttpInfo
     *
     * Replace crypto order
     *
     * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order&#39;s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $brokerage_order_id The Brokerage Order ID of the order to replace. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeReplaceForm $manual_trade_replace_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceOrderWithHttpInfo($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, string $contentType = self::contentTypes['replaceOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->replaceOrderRequest($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->replaceOrderWithHttpInfo(
                        $account_id,
                        $brokerage_order_id,
                        $user_id,
                        $user_secret,
                        $manual_trade_replace_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\SnapTrade\Model\Model403FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model403FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model403FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model403FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceOrderAsync
     *
     * Replace crypto order
     *
     * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order&#39;s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $brokerage_order_id The Brokerage Order ID of the order to replace. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeReplaceForm $manual_trade_replace_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceOrderAsync(

        $action,
        $order_type,
        $time_in_force,
        $account_id,
        $brokerage_order_id,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $symbol = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        string $contentType = self::contentTypes['replaceOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "symbol", $symbol);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $manual_trade_replace_form = $_body;

        return $this->replaceOrderAsyncWithHttpInfo($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceOrderAsyncWithHttpInfo
     *
     * Replace crypto order
     *
     * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order&#39;s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $brokerage_order_id The Brokerage Order ID of the order to replace. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeReplaceForm $manual_trade_replace_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceOrderAsyncWithHttpInfo($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, string $contentType = self::contentTypes['replaceOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->replaceOrderRequest($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceOrder'
     *
     * @param  string $account_id The ID of the account to execute the trade on. (required)
     * @param  string $brokerage_order_id The Brokerage Order ID of the order to replace. (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeReplaceForm $manual_trade_replace_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceOrderRequest($account_id, $brokerage_order_id, $user_id, $user_secret, $manual_trade_replace_form, string $contentType = self::contentTypes['replaceOrder'][0])
    {

        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling replaceOrder'
            );
        }
        // Check if $brokerage_order_id is a string
        if ($brokerage_order_id !== SENTINEL_VALUE && !is_string($brokerage_order_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($brokerage_order_id, true), gettype($brokerage_order_id)));
        }
        // verify the required parameter 'brokerage_order_id' is set
        if ($brokerage_order_id === SENTINEL_VALUE || (is_array($brokerage_order_id) && count($brokerage_order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter brokerage_order_id when calling replaceOrder'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling replaceOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling replaceOrder'
            );
        }
        if ($manual_trade_replace_form !== SENTINEL_VALUE) {
            if (!($manual_trade_replace_form instanceof \SnapTrade\Model\ManualTradeReplaceForm)) {
                if (!is_array($manual_trade_replace_form))
                    throw new \InvalidArgumentException('"manual_trade_replace_form" must be associative array or an instance of \SnapTrade\Model\ManualTradeReplaceForm TradingApi.replaceOrder.');
                else
                    $manual_trade_replace_form = new \SnapTrade\Model\ManualTradeReplaceForm($manual_trade_replace_form);
            }
        }
        // verify the required parameter 'manual_trade_replace_form' is set
        if ($manual_trade_replace_form === SENTINEL_VALUE || (is_array($manual_trade_replace_form) && count($manual_trade_replace_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter manual_trade_replace_form when calling replaceOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/trading/simple/{brokerageOrderId}/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brokerage_order_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'brokerageOrderId' . '}',
                ObjectSerializer::toPathValue($brokerage_order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manual_trade_replace_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($manual_trade_replace_form));
            } else {
                $httpBody = $manual_trade_replace_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'PATCH';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation searchCryptocurrencyPairInstruments
     *
     * Get crypto pairs
     *
     * Searches cryptocurrency pairs instruments accessible to the specified account.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  string $base base (optional)
     * @param  string $quote quote (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCryptocurrencyPairInstruments'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function searchCryptocurrencyPairInstruments(
        $user_id,
        $user_secret,
        $account_id,
        $base = SENTINEL_VALUE,
        $quote = SENTINEL_VALUE,

        string $contentType = self::contentTypes['searchCryptocurrencyPairInstruments'][0]
    )
    {

        list($response) = $this->searchCryptocurrencyPairInstrumentsWithHttpInfo($user_id, $user_secret, $account_id, $base, $quote, $contentType);
        return $response;
    }

    /**
     * Operation searchCryptocurrencyPairInstrumentsWithHttpInfo
     *
     * Get crypto pairs
     *
     * Searches cryptocurrency pairs instruments accessible to the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $base (optional)
     * @param  string $quote (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCryptocurrencyPairInstruments'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCryptocurrencyPairInstrumentsWithHttpInfo($user_id, $user_secret, $account_id, $base = null, $quote = null, string $contentType = self::contentTypes['searchCryptocurrencyPairInstruments'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->searchCryptocurrencyPairInstrumentsRequest($user_id, $user_secret, $account_id, $base, $quote, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->searchCryptocurrencyPairInstrumentsWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $base,
                        $quote,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCryptocurrencyPairInstrumentsAsync
     *
     * Get crypto pairs
     *
     * Searches cryptocurrency pairs instruments accessible to the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $base (optional)
     * @param  string $quote (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCryptocurrencyPairInstruments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCryptocurrencyPairInstrumentsAsync(
        $user_id,
        $user_secret,
        $account_id,
        $base = SENTINEL_VALUE,
        $quote = SENTINEL_VALUE,

        string $contentType = self::contentTypes['searchCryptocurrencyPairInstruments'][0]
    )
    {

        return $this->searchCryptocurrencyPairInstrumentsAsyncWithHttpInfo($user_id, $user_secret, $account_id, $base, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCryptocurrencyPairInstrumentsAsyncWithHttpInfo
     *
     * Get crypto pairs
     *
     * Searches cryptocurrency pairs instruments accessible to the specified account.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $base (optional)
     * @param  string $quote (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCryptocurrencyPairInstruments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCryptocurrencyPairInstrumentsAsyncWithHttpInfo($user_id, $user_secret, $account_id, $base = null, $quote = null, string $contentType = self::contentTypes['searchCryptocurrencyPairInstruments'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\TradingSearchCryptocurrencyPairInstruments200Response';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->searchCryptocurrencyPairInstrumentsRequest($user_id, $user_secret, $account_id, $base, $quote, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCryptocurrencyPairInstruments'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  string $base (optional)
     * @param  string $quote (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCryptocurrencyPairInstruments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchCryptocurrencyPairInstrumentsRequest($user_id, $user_secret, $account_id, $base = SENTINEL_VALUE, $quote = SENTINEL_VALUE, string $contentType = self::contentTypes['searchCryptocurrencyPairInstruments'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling searchCryptocurrencyPairInstruments'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling searchCryptocurrencyPairInstruments'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling searchCryptocurrencyPairInstruments'
            );
        }
        // Check if $base is a string
        if ($base !== SENTINEL_VALUE && !is_string($base)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($base, true), gettype($base)));
        }
        // Check if $quote is a string
        if ($quote !== SENTINEL_VALUE && !is_string($quote)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($quote, true), gettype($quote)));
        }


        $resourcePath = '/accounts/{accountId}/trading/instruments/cryptocurrencyPairs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($base !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $base,
                'base', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($quote !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $quote,
                'quote', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
