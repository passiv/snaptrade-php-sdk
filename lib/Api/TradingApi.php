<?php
/**
 * TradingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  SnapTrade
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * SnapTrade
 *
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 * Generated by: https://konfigthis.com
 */


namespace SnapTrade\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use SnapTrade\ApiException;
use SnapTrade\Configuration;
use SnapTrade\HeaderSelector;
use SnapTrade\ObjectSerializer;

class TradingApi extends \SnapTrade\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cancelUserAccountOrder' => [
            'application/json',
        ],
        'getOrderImpact' => [
            'application/json',
        ],
        'getUserAccountQuotes' => [
            'application/json',
        ],
        'placeForceOrder' => [
            'application/json',
        ],
        'placeOrder' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation cancelUserAccountOrder
     *
     * Cancel order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $account_id account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model500UnexpectedExceptionResponse
     */
    public function cancelUserAccountOrder(

        $user_id,
        $user_secret,
        $account_id,
        $brokerage_order_id = SENTINEL_VALUE,
        string $contentType = self::contentTypes['cancelUserAccountOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "brokerage_order_id", $brokerage_order_id);
        $trading_cancel_user_account_order_request = $_body;

        list($response) = $this->cancelUserAccountOrderWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType);
        return $response;
    }

    /**
     * Operation cancelUserAccountOrderWithHttpInfo
     *
     * Cancel order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model500UnexpectedExceptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelUserAccountOrderWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, string $contentType = self::contentTypes['cancelUserAccountOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->cancelUserAccountOrderRequest($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->cancelUserAccountOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $account_id,
                        $trading_cancel_user_account_order_request,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model500UnexpectedExceptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model500UnexpectedExceptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelUserAccountOrderAsync
     *
     * Cancel order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelUserAccountOrderAsync(

        $user_id,
        $user_secret,
        $account_id,
        $brokerage_order_id = SENTINEL_VALUE,
        string $contentType = self::contentTypes['cancelUserAccountOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "brokerage_order_id", $brokerage_order_id);
        $trading_cancel_user_account_order_request = $_body;

        return $this->cancelUserAccountOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelUserAccountOrderAsyncWithHttpInfo
     *
     * Cancel order
     *
     * Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelUserAccountOrderAsyncWithHttpInfo($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, string $contentType = self::contentTypes['cancelUserAccountOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->cancelUserAccountOrderRequest($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelUserAccountOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $account_id (required)
     * @param  \SnapTrade\Model\TradingCancelUserAccountOrderRequest $trading_cancel_user_account_order_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelUserAccountOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelUserAccountOrderRequest($user_id, $user_secret, $account_id, $trading_cancel_user_account_order_request, string $contentType = self::contentTypes['cancelUserAccountOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling cancelUserAccountOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling cancelUserAccountOrder'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling cancelUserAccountOrder'
            );
        }
        if ($trading_cancel_user_account_order_request !== SENTINEL_VALUE) {
            if (!($trading_cancel_user_account_order_request instanceof \SnapTrade\Model\TradingCancelUserAccountOrderRequest)) {
                if (!is_array($trading_cancel_user_account_order_request))
                    throw new \InvalidArgumentException('"trading_cancel_user_account_order_request" must be associative array or an instance of \SnapTrade\Model\TradingCancelUserAccountOrderRequest TradingApi.cancelUserAccountOrder.');
                else
                    $trading_cancel_user_account_order_request = new \SnapTrade\Model\TradingCancelUserAccountOrderRequest($trading_cancel_user_account_order_request);
            }
        }
        // verify the required parameter 'trading_cancel_user_account_order_request' is set
        if ($trading_cancel_user_account_order_request === SENTINEL_VALUE || (is_array($trading_cancel_user_account_order_request) && count($trading_cancel_user_account_order_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter trading_cancel_user_account_order_request when calling cancelUserAccountOrder'
            );
        }


        $resourcePath = '/accounts/{accountId}/orders/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($trading_cancel_user_account_order_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($trading_cancel_user_account_order_request));
            } else {
                $httpBody = $trading_cancel_user_account_order_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getOrderImpact
     *
     * Check order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\ManualTradeAndImpact|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse
     */
    public function getOrderImpact(

        $account_id,
        $action,
        $universal_symbol_id,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['getOrderImpact'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form = $_body;

        list($response) = $this->getOrderImpactWithHttpInfo($user_id, $user_secret, $manual_trade_form, $contentType);
        return $response;
    }

    /**
     * Operation getOrderImpactWithHttpInfo
     *
     * Check order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\ManualTradeAndImpact|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderImpactWithHttpInfo($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['getOrderImpact'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getOrderImpactRequest($user_id, $user_secret, $manual_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getOrderImpactWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $manual_trade_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\ManualTradeAndImpact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\ManualTradeAndImpact' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\ManualTradeAndImpact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\SnapTrade\Model\Model403FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model403FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model403FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\ManualTradeAndImpact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\ManualTradeAndImpact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model403FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderImpactAsync
     *
     * Check order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderImpactAsync(

        $account_id,
        $action,
        $universal_symbol_id,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['getOrderImpact'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form = $_body;

        return $this->getOrderImpactAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderImpactAsyncWithHttpInfo
     *
     * Check order impact
     *
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a &#x60;Trade&#x60; object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the &#x60;Trade&#x60; object returned expires after 5 minutes. Any order placed using an expired &#x60;Trade&#x60; will be rejected.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderImpactAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['getOrderImpact'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\ManualTradeAndImpact';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getOrderImpactRequest($user_id, $user_secret, $manual_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderImpact'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderImpact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderImpactRequest($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['getOrderImpact'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getOrderImpact'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getOrderImpact'
            );
        }
        if ($manual_trade_form !== SENTINEL_VALUE) {
            if (!($manual_trade_form instanceof \SnapTrade\Model\ManualTradeForm)) {
                if (!is_array($manual_trade_form))
                    throw new \InvalidArgumentException('"manual_trade_form" must be associative array or an instance of \SnapTrade\Model\ManualTradeForm TradingApi.getOrderImpact.');
                else
                    $manual_trade_form = new \SnapTrade\Model\ManualTradeForm($manual_trade_form);
            }
        }
        // verify the required parameter 'manual_trade_form' is set
        if ($manual_trade_form === SENTINEL_VALUE || (is_array($manual_trade_form) && count($manual_trade_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter manual_trade_form when calling getOrderImpact'
            );
        }


        $resourcePath = '/trade/impact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manual_trade_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($manual_trade_form));
            } else {
                $httpBody = $manual_trade_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getUserAccountQuotes
     *
     * Get symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. (required)
     * @param  string $account_id account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\SymbolsQuotesInner[]|\SnapTrade\Model\Model500UnexpectedExceptionResponse
     */
    public function getUserAccountQuotes(
        $user_id,
        $user_secret,
        $symbols,
        $account_id,
        $use_ticker = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getUserAccountQuotes'][0]
    )
    {

        list($response) = $this->getUserAccountQuotesWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType);
        return $response;
    }

    /**
     * Operation getUserAccountQuotesWithHttpInfo
     *
     * Get symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\SymbolsQuotesInner[]|\SnapTrade\Model\Model500UnexpectedExceptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserAccountQuotesWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker = null, string $contentType = self::contentTypes['getUserAccountQuotes'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getUserAccountQuotesRequest($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getUserAccountQuotesWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $symbols,
                        $account_id,
                        $use_ticker,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\SymbolsQuotesInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\SymbolsQuotesInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\SymbolsQuotesInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model500UnexpectedExceptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model500UnexpectedExceptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\SymbolsQuotesInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\SymbolsQuotesInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model500UnexpectedExceptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAccountQuotesAsync
     *
     * Get symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAccountQuotesAsync(
        $user_id,
        $user_secret,
        $symbols,
        $account_id,
        $use_ticker = SENTINEL_VALUE,

        string $contentType = self::contentTypes['getUserAccountQuotes'][0]
    )
    {

        return $this->getUserAccountQuotesAsyncWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAccountQuotesAsyncWithHttpInfo
     *
     * Get symbol quotes
     *
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAccountQuotesAsyncWithHttpInfo($user_id, $user_secret, $symbols, $account_id, $use_ticker = null, string $contentType = self::contentTypes['getUserAccountQuotes'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\SymbolsQuotesInner[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getUserAccountQuotesRequest($user_id, $user_secret, $symbols, $account_id, $use_ticker, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserAccountQuotes'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  string $symbols List of Universal Symbol IDs or tickers to get quotes for. (required)
     * @param  string $account_id (required)
     * @param  bool $use_ticker Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAccountQuotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserAccountQuotesRequest($user_id, $user_secret, $symbols, $account_id, $use_ticker = SENTINEL_VALUE, string $contentType = self::contentTypes['getUserAccountQuotes'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling getUserAccountQuotes'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling getUserAccountQuotes'
            );
        }
        // Check if $symbols is a string
        if ($symbols !== SENTINEL_VALUE && !is_string($symbols)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($symbols, true), gettype($symbols)));
        }
        // verify the required parameter 'symbols' is set
        if ($symbols === SENTINEL_VALUE || (is_array($symbols) && count($symbols) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter symbols when calling getUserAccountQuotes'
            );
        }
        // Check if $account_id is a string
        if ($account_id !== SENTINEL_VALUE && !is_string($account_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($account_id, true), gettype($account_id)));
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === SENTINEL_VALUE || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter account_id when calling getUserAccountQuotes'
            );
        }


        $resourcePath = '/accounts/{accountId}/quotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($symbols !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $symbols,
                'symbols', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($use_ticker !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $use_ticker,
                'use_ticker', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }


        // path params
        if ($account_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeForceOrder
     *
     * Place order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse
     */
    public function placeForceOrder(

        $account_id,
        $action,
        $universal_symbol_id,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeForceOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form = $_body;

        list($response) = $this->placeForceOrderWithHttpInfo($user_id, $user_secret, $manual_trade_form, $contentType);
        return $response;
    }

    /**
     * Operation placeForceOrderWithHttpInfo
     *
     * Place order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse|\SnapTrade\Model\Model403FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeForceOrderWithHttpInfo($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['placeForceOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeForceOrderRequest($user_id, $user_secret, $manual_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeForceOrderWithHttpInfo(
                        $user_id,
                        $user_secret,
                        $manual_trade_form,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\SnapTrade\Model\Model403FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model403FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model403FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model403FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeForceOrderAsync
     *
     * Place order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeForceOrderAsync(

        $account_id,
        $action,
        $universal_symbol_id,
        $order_type,
        $time_in_force,
        $user_id,
        $user_secret,
        $price = SENTINEL_VALUE,
        $stop = SENTINEL_VALUE,
        $units = SENTINEL_VALUE,
        $notional_value = SENTINEL_VALUE,
        string $contentType = self::contentTypes['placeForceOrder'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "account_id", $account_id);
        $this->setRequestBodyProperty($_body, "action", $action);
        $this->setRequestBodyProperty($_body, "universal_symbol_id", $universal_symbol_id);
        $this->setRequestBodyProperty($_body, "order_type", $order_type);
        $this->setRequestBodyProperty($_body, "time_in_force", $time_in_force);
        $this->setRequestBodyProperty($_body, "price", $price);
        $this->setRequestBodyProperty($_body, "stop", $stop);
        $this->setRequestBodyProperty($_body, "units", $units);
        $this->setRequestBodyProperty($_body, "notional_value", $notional_value);
        $manual_trade_form = $_body;

        return $this->placeForceOrderAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeForceOrderAsyncWithHttpInfo
     *
     * Place order
     *
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeForceOrderAsyncWithHttpInfo($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['placeForceOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeForceOrderRequest($user_id, $user_secret, $manual_trade_form, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeForceOrder'
     *
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ManualTradeForm $manual_trade_form (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeForceOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeForceOrderRequest($user_id, $user_secret, $manual_trade_form, string $contentType = self::contentTypes['placeForceOrder'][0])
    {

        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeForceOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeForceOrder'
            );
        }
        if ($manual_trade_form !== SENTINEL_VALUE) {
            if (!($manual_trade_form instanceof \SnapTrade\Model\ManualTradeForm)) {
                if (!is_array($manual_trade_form))
                    throw new \InvalidArgumentException('"manual_trade_form" must be associative array or an instance of \SnapTrade\Model\ManualTradeForm TradingApi.placeForceOrder.');
                else
                    $manual_trade_form = new \SnapTrade\Model\ManualTradeForm($manual_trade_form);
            }
        }
        // verify the required parameter 'manual_trade_form' is set
        if ($manual_trade_form === SENTINEL_VALUE || (is_array($manual_trade_form) && count($manual_trade_form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter manual_trade_form when calling placeForceOrder'
            );
        }


        $resourcePath = '/trade/place';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manual_trade_form)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($manual_trade_form));
            } else {
                $httpBody = $manual_trade_form;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation placeOrder
     *
     * Place checked order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id user_id (required)
     * @param  string $user_secret user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse
     */
    public function placeOrder(
        $trade_id,
        $user_id,
        $user_secret,
        $wait_to_confirm = SENTINEL_VALUE,

        string $contentType = self::contentTypes['placeOrder'][0]
    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "wait_to_confirm", $wait_to_confirm);
        $validated_trade_body = $_body;

        list($response) = $this->placeOrderWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType);
        return $response;
    }

    /**
     * Operation placeOrderWithHttpInfo
     *
     * Place checked order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \SnapTrade\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SnapTrade\Model\AccountOrderRecord|\SnapTrade\Model\Model400FailedRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeOrderWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body = null, string $contentType = self::contentTypes['placeOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeOrderRequest($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->placeOrderWithHttpInfo(
                        $trade_id,
                        $user_id,
                        $user_secret,
                        $validated_trade_body,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SnapTrade\Model\AccountOrderRecord' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\AccountOrderRecord' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\AccountOrderRecord', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\SnapTrade\Model\Model400FailedRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SnapTrade\Model\Model400FailedRequestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SnapTrade\Model\Model400FailedRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SnapTrade\Model\AccountOrderRecord';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\AccountOrderRecord',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SnapTrade\Model\Model400FailedRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeOrderAsync
     *
     * Place checked order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeOrderAsync(
        $trade_id,
        $user_id,
        $user_secret,
        $wait_to_confirm = SENTINEL_VALUE,

        string $contentType = self::contentTypes['placeOrder'][0]
    )
    {
        $_body = null;
        $this->setRequestBodyProperty($_body, "wait_to_confirm", $wait_to_confirm);
        $validated_trade_body = $_body;

        return $this->placeOrderAsyncWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeOrderAsyncWithHttpInfo
     *
     * Place checked order
     *
     * Places the previously checked order with the brokerage. The &#x60;tradeId&#x60; is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It&#39;s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeOrderAsyncWithHttpInfo($trade_id, $user_id, $user_secret, $validated_trade_body = null, string $contentType = self::contentTypes['placeOrder'][0], \SnapTrade\RequestOptions $requestOptions = new \SnapTrade\RequestOptions())
    {
        $returnType = '\SnapTrade\Model\AccountOrderRecord';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->placeOrderRequest($trade_id, $user_id, $user_secret, $validated_trade_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeOrder'
     *
     * @param  string $trade_id Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact) (required)
     * @param  string $user_id (required)
     * @param  string $user_secret (required)
     * @param  \SnapTrade\Model\ValidatedTradeBody $validated_trade_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['placeOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function placeOrderRequest($trade_id, $user_id, $user_secret, $validated_trade_body = SENTINEL_VALUE, string $contentType = self::contentTypes['placeOrder'][0])
    {

        // Check if $trade_id is a string
        if ($trade_id !== SENTINEL_VALUE && !is_string($trade_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($trade_id, true), gettype($trade_id)));
        }
        // verify the required parameter 'trade_id' is set
        if ($trade_id === SENTINEL_VALUE || (is_array($trade_id) && count($trade_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter trade_id when calling placeOrder'
            );
        }
        // Check if $user_id is a string
        if ($user_id !== SENTINEL_VALUE && !is_string($user_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_id, true), gettype($user_id)));
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === SENTINEL_VALUE || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_id when calling placeOrder'
            );
        }
        // Check if $user_secret is a string
        if ($user_secret !== SENTINEL_VALUE && !is_string($user_secret)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($user_secret, true), gettype($user_secret)));
        }
        // verify the required parameter 'user_secret' is set
        if ($user_secret === SENTINEL_VALUE || (is_array($user_secret) && count($user_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_secret when calling placeOrder'
            );
        }
        if ($validated_trade_body !== SENTINEL_VALUE) {
            if (!($validated_trade_body instanceof \SnapTrade\Model\ValidatedTradeBody)) {
                if (!is_array($validated_trade_body))
                    throw new \InvalidArgumentException('"validated_trade_body" must be associative array or an instance of \SnapTrade\Model\ValidatedTradeBody TradingApi.placeOrder.');
                else
                    $validated_trade_body = new \SnapTrade\Model\ValidatedTradeBody($validated_trade_body);
            }
        }


        $resourcePath = '/trade/{tradeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($user_id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_id,
                'userId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($user_secret !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $user_secret,
                'userSecret', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }


        // path params
        if ($trade_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'tradeId' . '}',
                ObjectSerializer::toPathValue($trade_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validated_trade_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($validated_trade_body));
            } else {
                $httpBody = $validated_trade_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('clientId');
        if ($apiKey !== null) {
            $queryParams['clientId'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Signature');
        if ($apiKey !== null) {
            $headers['Signature'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('timestamp');
        if ($apiKey !== null) {
            $queryParams['timestamp'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
